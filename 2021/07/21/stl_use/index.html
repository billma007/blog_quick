<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>C++中如何使用struct和STL创建链表结构 • Bill Ma's Blog(smarter....)</title><meta name="description" content="C++中如何使用struct和STL创建链表结构 - BillMa"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Bill Ma's Blog(smarter....)"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Bill Ma's Blog(smarter....)" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Bill Ma's Blog(smarter....)"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++中如何使用struct和STL创建链表结构</h1><div class="post-info"><a></a>2021-07-21</div><div class="post-content"><h2 id="一-链表结构的使用"><a href="#一-链表结构的使用" class="headerlink" title="一.链表结构的使用"></a>一.链表结构的使用</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//该链数据</span></span><br><span class="line">    node *next;<span class="comment">//指向链表下一个数据</span></span><br><span class="line">&#125;</span><br><span class="line">node *p;<span class="comment">//链表所在的地址</span></span><br></pre></td></tr></table></figure>

<h3 id="2-新增存储单元"><a href="#2-新增存储单元" class="headerlink" title="2.新增存储单元"></a>2.新增存储单元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="keyword">new</span> node;</span><br></pre></td></tr></table></figure>

<h3 id="3-其他所需的操作符"><a href="#3-其他所需的操作符" class="headerlink" title="3.其他所需的操作符"></a>3.其他所需的操作符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node *head;<span class="comment">//指向头节点</span></span><br><span class="line">node *p;<span class="comment">//用来申请新的数据单元</span></span><br><span class="line">node *r;<span class="comment">//用来指向末节点(最后一个数据)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-输入一个链表"><a href="#4-输入一个链表" class="headerlink" title="4.输入一个链表"></a>4.输入一个链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//每次输入的数据</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="keyword">while</span> (<span class="comment">/*输入链条的终止条件*/</span>)&#123;</span><br><span class="line">    p=<span class="keyword">new</span> node;<span class="comment">//申请一个新节点</span></span><br><span class="line">    p-&gt;data=x;<span class="comment">//录入数据</span></span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//初始化下一个节点避免闪退</span></span><br><span class="line">    r-&gt;next=p;<span class="comment">//将新节点接到前面链表中</span></span><br><span class="line">    r=p;<span class="comment">//末节点后移</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//输入下一个数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-输出链表"><a href="#5-输出链表" class="headerlink" title="5.输出链表"></a>5.输出链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;<span class="comment">//p指针回到链表开头</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);</span><br><span class="line">    p=p-&gt;next;<span class="comment">//到下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,p-&gt;data);<span class="comment">//把最后一个数据也输出</span></span><br></pre></td></tr></table></figure>

<h3 id="6-查找某个条件的数据"><a href="#6-查找某个条件的数据" class="headerlink" title="6.查找某个条件的数据"></a>6.查找某个条件的数据</h3><h4 id="a-查找满足一定条件的节点"><a href="#a-查找满足一定条件的节点" class="headerlink" title="a.查找满足一定条件的节点"></a>a.查找满足一定条件的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>((p-&gt;data !=(满足的条件))&amp;&amp;(p-&gt;next !=<span class="literal">NULL</span>))p=p-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;data ==(满足的条件))处理该数据;</span><br><span class="line"><span class="keyword">else</span> 输出不存在;</span><br></pre></td></tr></table></figure>

<h4 id="b-查找所有满足条件的点"><a href="#b-查找所有满足条件的点" class="headerlink" title="b.查找所有满足条件的点"></a>b.查找所有满足条件的点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p=head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data==(满足的条件))&#123;</span><br><span class="line">        <span class="comment">/*处理该数据*/</span></span><br><span class="line">    &#125;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二-使用STL容器进行"><a href="#二-使用STL容器进行" class="headerlink" title="二.使用STL容器进行"></a>二.使用STL容器进行</h2><h3 id="a-set"><a href="#a-set" class="headerlink" title="a.set"></a>a.set</h3><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><p>无序，随机，类似于指针（但其实不是指针，STL容器过于强大）</p>
<h4 id="2-头文件"><a href="#2-头文件" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h4 id="3-定义容器"><a href="#3-定义容器" class="headerlink" title="3.定义容器"></a>3.定义容器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;name</span><br><span class="line"><span class="comment">/*例：*/</span>set&lt;string&gt;class_set;<span class="comment">//类中的一个学生列表</span></span><br></pre></td></tr></table></figure>

<h4 id="4-添加元素"><a href="#4-添加元素" class="headerlink" title="4.添加元素"></a>4.添加元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="comment">/*满足条件*/</span>)&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    class_set.<span class="built_in">insert</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-输出学生集合（无序的）"><a href="#5-输出学生集合（无序的）" class="headerlink" title="5.输出学生集合（无序的）"></a>5.输出学生集合（无序的）</h4><h5 id="1-创建迭代器"><a href="#1-创建迭代器" class="headerlink" title="[1]创建迭代器"></a>[1]创建迭代器</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;kind&gt;::const_iterator cur_name;<span class="comment">//cur_name为迭代器</span></span><br><span class="line"><span class="comment">/*example*/</span>set&lt;string&gt;::const_iterator cur_student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-遍历输出"><a href="#2-遍历输出" class="headerlink" title="[2]遍历输出"></a>[2]遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(cur_student = class_set.<span class="built_in">begin</span>();</span><br><span class="line">    cur_student !=class_set.<span class="built_in">end</span>();</span><br><span class="line">    cur_student++)cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cur_student被定义成string类型的迭代器，类似于指针地址</p>
</blockquote>
<blockquote>
<p>初始条件：cur_student指针指向class_set.begin()的地址</p>
</blockquote>
<blockquote>
<p>终止条件：cur_student指针指向class_set.end()的地址</p>
</blockquote>
<p><em><strong>注意：不能将for循环里面的！&#x3D;改成&lt;或者其他符号，因为列表是无序的。++指的是地址后移一位，而不是数字+1</strong></em></p>
<h5 id="3-使用foreach函数进行遍历输出"><a href="#3-使用foreach函数进行遍历输出" class="headerlink" title="[3]使用foreach函数进行遍历输出"></a>[3]使用foreach函数进行遍历输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.头文件*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">/*2.创建输出指令*/</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">write</span><span class="params">(set&lt;string&gt;::const_iterator cur_student)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;*cur_student&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.使用foreach进行遍历*/</span></span><br><span class="line">foreach(class_set.<span class="built_in">begin</span>(),class_set.<span class="built_in">end</span>(),write);</span><br></pre></td></tr></table></figure>

<h4 id="6-其它"><a href="#6-其它" class="headerlink" title="6.其它"></a>6.其它</h4><p>set容器当中不能有重复的元素，否则程序会意外终止。如果你想要存放重复元素，你可以将上述set换成multiset即可。</p>
<h3 id="b-map"><a href="#b-map" class="headerlink" title="b.map"></a>b.map</h3><h4 id="1-特点-1"><a href="#1-特点-1" class="headerlink" title="1.特点"></a>1.特点</h4><p>不同于set，map有两个值，第一个可以称为关键字(key)，每个关键字只能在map中出现一次；第二个可能称为该关键字的值(value)；</p>
<p>key在一个map只能出现一次，但是value可以出现多次。</p>
<p>key和value是一对一(one-to-one)的，而不同于set，map是有序对。</p>
<h4 id="2-头文件-1"><a href="#2-头文件-1" class="headerlink" title="2.头文件"></a>2.头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<h4 id="3-声明map"><a href="#3-声明map" class="headerlink" title="3.声明map"></a>3.声明map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std:map&lt;type1,type2&gt; variable;</span><br><span class="line"><span class="comment">/*example*/</span>std:map&lt;<span class="type">int</span>,string&gt; person;</span><br></pre></td></tr></table></figure>

<p>当然，如果你觉得每次都定义一个map太烦了，你可以使用<code>typedef</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>,string&gt; mapp;</span><br><span class="line">mapp variable1;</span><br><span class="line">mapp variable2;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="4-加入元素"><a href="#4-加入元素" class="headerlink" title="4.加入元素"></a>4.加入元素</h4><p>现在，我们已经声明了一个叫做<code>variable</code>的map容器(你自己随便声明一个也无所谓)。插入有几种方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//First Kind:INSERT function</span></span><br><span class="line"><span class="comment">//1.insert+pair</span></span><br><span class="line">varibale.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;type1,type2&gt;(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;Bill Gates&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.insert+value_type</span></span><br><span class="line">variable.<span class="built_in">insert</span>(map&lt;type1,type2&gt;::<span class="built_in">value_type</span>(key,value));</span><br><span class="line"><span class="comment">/*example*/</span>variable.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>,string&gt;::<span class="built_in">value_type</span>(<span class="number">2</span>,<span class="string">&quot;Jeff Bezos&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Second Kind:Array[]</span></span><br><span class="line">variable[key]=value;</span><br><span class="line"><span class="comment">/*example*/</span>variable[<span class="number">3</span>]=<span class="string">&quot;Michael Dell&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>为什么我要分为两种呢？因为使用insert+pair和insert+value_type组合效果是相同的。他俩都是通过insert函数插入数据。但是，如果某key已经有了一个value，insert函数是会自动跳过不执行指令的。如果使用array数组进行插入，新输入的数据就会把原有的数据覆盖住。</p>
<h4 id="5-查找元素"><a href="#5-查找元素" class="headerlink" title="5.查找元素"></a>5.查找元素</h4><p>这个时候又要用到迭代器了。先声明一个迭代器iterate，随后循环查找：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iterate = variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="keyword">while</span>(iterate != variable.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="comment">/*处理该数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-删除元素"><a href="#6-删除元素" class="headerlink" title="6.删除元素"></a>6.删除元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.iterate</span></span><br><span class="line">iterate =variable.<span class="built_in">find</span>(key);</span><br><span class="line"><span class="type">int</span> del =variable.<span class="built_in">erase</span>(iterate);</span><br><span class="line"><span class="comment">//erase函数删除成功返回1，否则返回0，下同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.key</span></span><br><span class="line"><span class="type">int</span> del =variable.<span class="built_in">erase</span>(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.delete key1~key2</span></span><br><span class="line"><span class="type">int</span> del =variable.<span class="built_in">erase</span>(key1,key2);</span><br><span class="line"><span class="comment">//把key1到key2之间所有的数据全部删除</span></span><br><span class="line"><span class="comment">//如果想删除某map所有数据，有以下两种办法：</span></span><br><span class="line"><span class="comment">/*1*/</span><span class="type">int</span> del =variable.<span class="built_in">erase</span>(variable.<span class="built_in">begin</span>(),variable.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">/*2*/</span><span class="type">int</span> del =variable.<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>

<h4 id="7-map大小"><a href="#7-map大小" class="headerlink" title="7.map大小"></a>7.map大小</h4><p>我怎么知道map里面目前有多少数据呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num =variable.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>


<p>未完待续。。。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2021/08/01/cpp-string/">prev</a><a class="next" href="/2021/07/10/myfirstblog/">next</a></div><div class="copyright"><p>&copy; 2022 <a href="https://q.billma.top">BillMa</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>