<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>C++ 中string用法详解 • Bill Ma's Blog(smarter....)</title><meta name="description" content="C++ 中string用法详解 - BillMa"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Bill Ma's Blog(smarter....)"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Bill Ma's Blog(smarter....)" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Bill Ma's Blog(smarter....)"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++ 中string用法详解</h1><div class="post-info"><a></a>2021-08-01</div><div class="post-content"><p><em>本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载</em></p>
<hr>
<p>C++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是C&#x2F;C++的文本处理功能太麻烦，用起来很不方便。</p>
<p>举例来说，如果文本格式是：用户名 电话号码，文件名name.txt</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">Jenny <span class="number">22231231</span> </span><br><span class="line">Heny <span class="number">22183942</span> </span><br><span class="line">Tom <span class="number">23245332</span> </span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>现在我们需要对用户名排序，且只输出不同的姓名。</p>
<p>那么在shell 编程中，可以这样用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;print $1&#125;&#x27; name.txt | sort | uniq</span><br></pre></td></tr></table></figure>

<p>如果使用C&#x2F;C++ 就麻烦了，他需要做以下工作： 先打开文件，检测文件是否打开，如果失败，则退出。 声明一个足够大得二维字符数组或者一个字符指针数组 读入一行到字符空间 然后分析一行的结构，找到空格，存入字符数组中。 关闭文件 写一个排序函数，或者使用写一个比较函数，使用sort()排序 遍历数组，比较是否有相同的，如果有，则要删除，copy… 输出信息</p>
<p>你可以用C++或者C语言去实现这个流程。如果一个人的主要工作就是处理这种类似的文本(例如做apache的日志统计和分析),你说他会喜欢C&#x2F;C++么？</p>
<p>当然，有了STL，这些处理会得到很大的简化。我们可以使用 fstream来代替麻烦的fopen fread fclose, 用vector来代替数组。最重要的是用 string来代替char * 数组，使用sort排序算法来排序，用unique 函数来去重。听起来好像很不错。看看下面代码(例程1）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;name.txt&quot;</span>)</span></span>;</span><br><span class="line">    string strtmp;</span><br><span class="line">    vector&lt;string&gt; vect;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(in, strtmp, <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    vect.<span class="built_in">push_back</span>(strtmp.<span class="built_in">substr</span>(<span class="number">0</span>, strtmp.<span class="built_in">find</span>(<span class="string">&#x27; &#x27;</span>)));</span><br><span class="line">    <span class="built_in">sort</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    vector&lt;string&gt;::iterator it=<span class="built_in">unique</span>(vect.<span class="built_in">begin</span>(), vect.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">copy</span>(vect.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">&quot;\n&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也还不错吧，至少会比想象得要简单得多！（代码里面没有对错误进行处理，只是为了说明问题，不要效仿).</p>
<p>当然，在这个文本格式中，不用vector而使用map会更有扩充性，例如，还可通过人名找电话号码等等，但是使用了map就不那么好用sort了。你可以用map试一试。</p>
<p>这里string的作用不只是可以存储字符串，还可以提供字符串的比较，查找等。在sort和unique函数中就默认使用了less 和equal_to函数, 上面的一段代码，其实使用了string的以下功能： 存储功能，在getline() 函数中 查找功能，在find() 函数中 子串功能，在substr() 函数中 string operator &lt; , 默认在sort() 函数中调用 string operator &#x3D;&#x3D; , 默认在unique() 函数中调用</p>
<p>总之，有了string 后，C++的字符文本处理功能总算得到了一定补充，加上配合STL其他容器使用，其在文本处理上的功能已经与perl, shell, php的距离缩小很多了。 因此掌握string 会让你的工作事半功倍。</p>
<h3 id="1-string使用"><a href="#1-string使用" class="headerlink" title="1.string使用"></a>1.string使用</h3><p>其实，string并不是一个单独的容器，只是basic_string 模板类的一个typedef 而已，相对应的还有wstring, 你在string 头文件中你会发现下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C++&quot;</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="type">char</span>&gt; string;</span><br><span class="line"><span class="keyword">typedef</span> basic_string &lt;<span class="type">wchar_t</span>&gt; wstring;</span><br><span class="line">&#125; <span class="comment">// extern &quot;C++&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于只是解释string的用法，如果没有特殊的说明，本文并不区分string 和 basic_string的区别。</p>
<p>string 其实相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括：增加、删除、修改、查找比较、链接、输入、输出等。详细函数列表参看附录。不要害怕这么多函数，其实有许多是序列容器带有的，平时不一定用的上。</p>
<p>如果你要想了解所有函数的详细用法，你需要查看basic_string，或者下载STL编程手册。这里通过实例介绍一些常用函数。</p>
<h4 id="1-1-充分使用string-操作符"><a href="#1-1-充分使用string-操作符" class="headerlink" title="1.1 充分使用string 操作符"></a>1.1 充分使用string 操作符</h4><p>string 重载了许多操作符，包括 +, +&#x3D;, &lt;, &#x3D;, , [], «, »等，正式这些操作符，对字符串操作非常方便。先看看下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot;Please input your name:&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo ;</span><br><span class="line">    cin &gt;&gt; strinfo;</span><br><span class="line">    <span class="keyword">if</span>( strinfo == <span class="string">&quot;winter&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are winter!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo != <span class="string">&quot;wende&quot;</span> )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;you are not wende!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( strinfo &lt; <span class="string">&quot;winter&quot;</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be ahead of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your name should be after of winter&quot;</span>&lt;&lt;endl;</span><br><span class="line">    strinfo += <span class="string">&quot; , Welcome to China!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; strinfo&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;Your name is :&quot;</span>&lt;&lt;endl;</span><br><span class="line">    string strtmp = <span class="string">&quot;How are you? &quot;</span> + strinfo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; strtmp.<span class="built_in">size</span>(); i ++)</span><br><span class="line">        cout&lt;&lt;strtmp[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面是程序的输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Please input your name:Hero</span></span><br><span class="line"><span class="comment">you are not wende!</span></span><br><span class="line"><span class="comment">Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">How are you? Hero , Welcome to China!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了这些操作符，在STL中仿函数都可以直接使用string作为参数，例如 less, great, equal_to 等，因此在把string作为参数传递的时候，它的使用和int 或者float等已经没有什么区别了。例如，你可以使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; mymap; <span class="comment">//以上默认使用了 less&lt;string&gt;</span></span><br></pre></td></tr></table></figure>

<p>有了 operator + 以后，你可以直接连加，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string strinfo=<span class="string">&quot;Winter&quot;</span>;</span><br><span class="line">string strlast=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">string strtest=<span class="string">&quot;Hello &quot;</span> + strinfo + <span class="string">&quot; Welcome&quot;</span> + <span class="string">&quot; to China&quot;</span> + <span class="string">&quot; !&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>看见其中的特点了吗？只要你的等式里面有一个 string 对象，你就可以一直连续”+”，但有一点需要保证的是，在开始的两项中，必须有一项是 string 对象。其原理很简单：</p>
<p>系统遇到”+“号，发现有一项是string 对象。 系统把另一项转化为一个临时 string 对象。 执行 operator + 操作，返回新的临时string 对象。 如果又发现”+“号，继续第一步操作。</p>
<p>由于这个等式是由左到右开始检测执行，如果开始两项都是const char<em>，程序自己并没有定义两个const char</em> 的加法，编译的时候肯定就有问题了。</p>
<p>有了操作符以后，assign(), append(), compare(), at()等函数，除非有一些特殊的需求时，一般是用不上。当然at()函数还有一个功能，那就是检查下标是否合法，如果是使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">&quot;winter&quot;</span>;<span class="comment">//下面一行有可能会引起程序中断错误</span></span><br><span class="line">str[<span class="number">100</span>]=<span class="string">&#x27;!&#x27;</span>;<span class="comment">//下面会抛出异常:throws: out_of_range</span></span><br><span class="line">cout&lt;&lt;str.<span class="built_in">at</span>(<span class="number">100</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>了解了吗？如果你希望效率高，还是使用[]来访问，如果你希望稳定性好，最好使用at()来访问。</p>
<h4 id="1-2-眼花缭乱的string-find-函数"><a href="#1-2-眼花缭乱的string-find-函数" class="headerlink" title="1.2 眼花缭乱的string find 函数"></a>1.2 眼花缭乱的string find 函数</h4><p>由于查找是使用最为频繁的功能之一，string 提供了非常丰富的查找函数。其列表如下： 函数名 描述 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置以上函数都是被重载了4次，以下是以find_first_of 函数为例说明他们的参数，其他函数和其参数一样，也就是说总共有24个函数 ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> basic_string&amp; s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> charT* s, size_type pos, size_type n)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(<span class="type">const</span> charT* s, size_type pos = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">size_type <span class="title">find_first_of</span><span class="params">(charT c, size_type pos = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>所有的查找函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int 或者unsigned int等类型。其实string::npos表示的是-1, 看看头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_CharT</span>, <span class="keyword">class</span> <span class="title class_">_Traits</span>, <span class="keyword">class</span> <span class="title class_">_Alloc</span>&gt;</span><br><span class="line"><span class="type">const</span> basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type</span><br><span class="line">basic_string&lt;_CharT,_Traits,_Alloc&gt;::npos</span><br><span class="line">= basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type) <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>

<p>find 和 rfind 都还比较容易理解，一个是正向匹配，一个是逆向匹配，后面的参数pos都是用来指定起始查找位置。对于find_first_of 和find_last_of 就不是那么好理解。</p>
<p>find_first_of 是给定一个要查找的字符集，找到这个字符集中任何一个字符所在字符串中第一个位置。或许看一个例子更容易明白。</p>
<p>有这样一个需求：过滤一行开头和结尾的所有非英文字符。看看用string 如何实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string strinfo=<span class="string">&quot; //*---Hello Word!......------&quot;</span>;</span><br><span class="line">    string strset=<span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;</span>;</span><br><span class="line">    <span class="type">int</span> first = strinfo.<span class="built_in">find_first_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(first == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> last = strinfo.<span class="built_in">find_last_of</span>(strset);</span><br><span class="line">     <span class="keyword">if</span>(last == string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;not find any characters&quot;</span>&lt;&lt;endl;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     cout &lt;&lt; strinfo.<span class="built_in">substr</span>(first, last - first + <span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把所有的英文字母大小写作为了需要查找的字符集，先查找第一个英文字母的位置，然后查找最后一个英文字母的位置，然后用substr 来的到中间的一部分，用于输出结果。下面就是其结果：<code>Hello Word</code><br>前面的符号和后面的符号都没有了。像这种用法可以用来查找分隔符，从而把一个连续的字符串分割成为几部分，达到 shell 命令中的 awk 的用法。特别是当分隔符有多个的时候，可以一次指定。例如有这样的需求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三|3456123, 湖南</span><br><span class="line">李四,4564234| 湖北</span><br><span class="line">王小二, 4433253|北京</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们需要以 “|” “,“为分隔符，同时又要过滤空格，把每行分成相应的字段。</p>
<p>1.3 string insert, replace, erase</p>
<p>了解了string 的操作符，查找函数和substr，其实就已经了解了string的80%的操作了。insert函数, replace函数和erase函数在使用起来相对简单。下面以一个例子来说明其应用。 string只是提供了按照位置和区间的replace函数，而不能用一个string字串来替换指定string中的另一个字串。这里写一个函数来实现这个功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="type">const</span> string &amp; strsrc, <span class="type">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">    string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">     &#123;</span><br><span class="line">      strBig.<span class="built_in">replace</span>(pos, srclen, strdst);</span><br><span class="line">      pos += dstlen;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看如何调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string strinfo=<span class="string">&quot;This is Winter, Winter is a programmer. Do you know Winter?&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Orign string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">string_replace</span>(strinfo, <span class="string">&quot;Winter&quot;</span>, <span class="string">&quot;wende&quot;</span>);</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;After replace Winter with wende, the string is :\n&quot;</span>&lt;&lt;strinfo&lt;&lt;endl;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其输出结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Orign string is :</span><br><span class="line">This is Winter, Winter is a programmer. Do you know Winter?</span><br><span class="line">After replace Winter with wende, the string is :</span><br><span class="line">This is wende, wende is a programmer. Do you know wende?</span><br></pre></td></tr></table></figure>

<p>如果不用replace函数，则可以使用erase和insert来替换，也能实现string_replace函数的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">string_replace</span><span class="params">(string &amp; strBig, <span class="type">const</span> string &amp; strsrc, <span class="type">const</span> string &amp;strdst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     string::size_type pos=<span class="number">0</span>;</span><br><span class="line">     string::size_type srclen=strsrc.<span class="built_in">size</span>();</span><br><span class="line">    string::size_type dstlen=strdst.<span class="built_in">size</span>();</span><br><span class="line">     <span class="keyword">while</span>( (pos=strBig.<span class="built_in">find</span>(strsrc, pos)) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">     strBig.<span class="built_in">erase</span>(pos, srclen);</span><br><span class="line">     strBig.<span class="built_in">insert</span>(pos, strdst);</span><br><span class="line">     pos += dstlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，这种方法没有使用replace来得直接.</p>
<h3 id="2-string-和C-style字符串"><a href="#2-string-和C-style字符串" class="headerlink" title="2 string 和C-style字符串"></a>2 string 和C-style字符串</h3><p>现在看了这么多例子，发现const char* 可以和string 直接转换，例如我们在上面的例子中，使用</p>
<p><code>string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);</code>来代用<code>void</code></p>
<p><code>string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)</code><br>在C语言中只有<code>char*</code> 和 <code>const char*</code>，为了使用起来方便，string提供了三个函数满足其要求：</p>
<p>const charT<em>c_str() const<br>const charT</em> data() const<br>size_type copy(charT* buf, size_type n, size_type pos &#x3D; 0) const<br>其中： c_str 直接返回一个以\0结尾的字符串。 data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有\0字符。 copy 把string的内容拷贝到buf空间中。 你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> charT* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">length</span> () == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">terminate</span> ();</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">data</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。</p>
<p>对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。</p>
<p>另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">string <span class="title">strinfo</span><span class="params">(<span class="string">&quot;this is Winter&quot;</span>)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//最好的方式是:</span></span><br><span class="line"><span class="built_in">foo</span>(strinfo.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="comment">//也可以这么用:</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* pstr=strinfo.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">foo</span>(pstr);</span><br><span class="line"><span class="comment">//不要再使用了pstr了, 下面的操作已经使pstr无效了。</span></span><br><span class="line">strinfo += <span class="string">&quot; Hello!&quot;</span>;</span><br><span class="line"><span class="built_in">foo</span>(pstr);<span class="comment">//错误！</span></span><br></pre></td></tr></table></figure>

<p>会遇到什么错误？当你幸运的时候pstr可能只是指向<code>&quot;this is Winter Hello!“</code>的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。</p>
<h3 id="3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了"><a href="#3-string-和-Charactor-Traits-了解了string的用法，该详细看看string的真相了" class="headerlink" title="3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了"></a>3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了</h3><p>前面提到string 只是basic_string的一个typedef。看看basic_string 的参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">charT</span>, <span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;,</span><br><span class="line"><span class="keyword">class</span> Allocator = allocator&lt;charT&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> basic_string</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char_traits不仅是在basic_string 中有用，在basic_istream 和 basic_ostream中也需要用到。 就像Steve Donovan在过度使用C++模板中提到的，这些确实有些过头了，要不是系统自己定义了相关的一些属性，而且用了个<span class="keyword">typedef</span>，否则还真不知道如何使用。</span><br><span class="line"></span><br><span class="line">但复杂总有复杂道理。有了char_traits，你可以定义自己的字符串类型。当然，有了char_traits &lt; <span class="type">char</span> &gt; 和char_traits &lt; <span class="type">wchar_t</span> &gt; 你的需求使用已经足够了，为了更好的理解string ，咱们来看看char_traits都有哪些要求。</span><br><span class="line"></span><br><span class="line">如果你希望使用你自己定义的字符，你必须定义包含下列成员的结构： 表达式 描述</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">char_type 字符类型</span><br><span class="line">int_type <span class="type">int</span> 类型</span><br><span class="line">pos_type 位置类型</span><br><span class="line">off_type 表示位置之间距离的类型</span><br><span class="line">state_type 表示状态的类型</span><br><span class="line"><span class="built_in">assign</span>(c1,c2) 把字符c2赋值给c1</span><br><span class="line"><span class="built_in">eq</span>(c1,c2) 判断c1,c2 是否相等</span><br><span class="line"><span class="built_in">lt</span>(c1,c2) 判断c1是否小于c2</span><br><span class="line"><span class="built_in">length</span>(str) 判断str的长度</span><br><span class="line"><span class="built_in">compare</span>(s1,s2,n) 比较s1和s2的前n个字符</span><br><span class="line"><span class="built_in">copy</span>(s1,s2, n) 把s2的前n个字符拷贝到s1中</span><br><span class="line"><span class="built_in">move</span>(s1,s2, n) 把s2中的前n个字符移动到s1中</span><br><span class="line"><span class="built_in">assign</span>(s,n,c) 把s中的前n个字符赋值为c</span><br><span class="line"><span class="built_in">find</span>(s,n,c) 在s的前n个字符内查找c</span><br><span class="line"><span class="built_in">eof</span>() 返回end-of-file</span><br><span class="line"><span class="built_in">to_int_type</span>(c) 将c转换成int_type</span><br><span class="line"><span class="built_in">to_char_type</span>(i) 将i转换成char_type</span><br><span class="line"><span class="built_in">not_eof</span>(i) 判断i是否为EOF</span><br><span class="line"><span class="built_in">eq_int_type</span>(i1,i2) 判断i1和i2是否相等</span><br></pre></td></tr></table></figure>

<p>想看看实际的例子，你可以看看sgi STL的char_traits结构源码.</p>
<p>现在默认的string版本中，并不支持忽略大小写的比较函数和查找函数，如果你想练练手，你可以试试改写一个char_traits , 然后生成一个case_string类, 也可以在string 上做继承，然后派生一个新的类，例如：ext_string，提供一些常用的功能，例如：</p>
<p>定义分隔符。给定分隔符，把string分为几个字段。 提供替换功能。例如，用winter, 替换字符串中的wende 大小写处理。例如，忽略大小写比较，转换等 整形转换。例如把”123”字符串转换为123数字。 这些都是常用的功能，如果你有兴趣可以试试。其实有人已经实现了，看看Extended STL string。如果你想偷懒，下载一个头文件就可以用，有了它确实方便了很多。要是有人能提供一个支持正则表达式的string，我会非常乐意用。</p>
<h3 id="4-string-建议"><a href="#4-string-建议" class="headerlink" title="4.string 建议"></a>4.string 建议</h3><p>使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。 string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’\0’结束，千万不可忽视。 尽量去使用操作符，这样可以让程序更加易懂</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p> 难怪有人说：string 使用方便功能强，我们一直用它！</p>
<h3 id="6-附录"><a href="#6-附录" class="headerlink" title="6 附录"></a>6 附录</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">string 函数列表 函数名 描述</span><br><span class="line">begin 得到指向字符串开头的Iterator</span><br><span class="line">end 得到指向字符串结尾的Iterator</span><br><span class="line">rbegin 得到指向反向字符串开头的Iterator</span><br><span class="line">rend 得到指向反向字符串结尾的Iterator</span><br><span class="line">size 得到字符串的大小</span><br><span class="line">length 和size函数功能相同</span><br><span class="line">max_size 字符串可能的最大大小</span><br><span class="line">capacity 在不重新分配内存的情况下，字符串可能的大小</span><br><span class="line">empty 判断是否为空</span><br><span class="line"><span class="keyword">operator</span>[] 取第几个元素，相当于数组</span><br><span class="line">c_str 取得C风格的<span class="type">const</span> <span class="type">char</span>* 字符串</span><br><span class="line">data 取得字符串内容地址</span><br><span class="line"><span class="keyword">operator</span>= 赋值操作符</span><br><span class="line">reserve 预留空间</span><br><span class="line">swap 交换函数</span><br><span class="line">insert 插入字符</span><br><span class="line">append 追加字符</span><br><span class="line">push_back 追加字符</span><br><span class="line"><span class="keyword">operator</span>+= += 操作符</span><br><span class="line">erase 删除字符串</span><br><span class="line">clear 清空字符容器中所有内容</span><br><span class="line">resize 重新分配空间</span><br><span class="line">assign 和赋值操作符一样</span><br><span class="line">replace 替代</span><br><span class="line">copy 字符串到空间</span><br><span class="line">find 查找</span><br><span class="line">rfind 反向查找</span><br><span class="line">find_first_of 查找包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_first_not_of 查找不包含子串中的任何字符，返回第一个位置</span><br><span class="line">find_last_of 查找包含子串中的任何字符，返回最后一个位置</span><br><span class="line">find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置</span><br><span class="line">substr 得到字串</span><br><span class="line">compare 比较字符串</span><br><span class="line"><span class="keyword">operator</span>+ 字符串链接</span><br><span class="line"><span class="keyword">operator</span>== 判断是否相等</span><br><span class="line"><span class="keyword">operator</span>!= 判断是否不等于</span><br><span class="line"><span class="keyword">operator</span>&lt; 判断是否小于</span><br><span class="line"><span class="keyword">operator</span>&gt;&gt; 从输入流中读入字符串</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt; 字符串写入输出流</span><br><span class="line">getline 从输入流中读入一行 </span><br></pre></td></tr></table></figure>

<p>之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 &#x3D; 进行赋值操作，&#x3D;&#x3D; 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。 好了，进入正题……… 首先，为了在我们的程序中使用string类型，我们必须包含头文件<code>&lt;cstring&gt;</code>。</p>
<h4 id="1．声明一个C-字符串"><a href="#1．声明一个C-字符串" class="headerlink" title="1．声明一个C++字符串"></a>1．声明一个C++字符串</h4><p>声明一个字符串变量很简单：<br><code>string Str;</code><br>这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a)    string s;  <span class="comment">//生成一个空字符串s</span></span><br><span class="line">b)    <span class="function">string <span class="title">s</span><span class="params">(str)</span> <span class="comment">//拷贝构造函数 生成str的复制品</span></span></span><br><span class="line"><span class="function">c)    string <span class="title">s</span><span class="params">(str,stridx)</span> <span class="comment">//将字符串str内“始于位置stridx”的部分当作字符串的初值</span></span></span><br><span class="line"><span class="function">d)    string <span class="title">s</span><span class="params">(str,stridx,strlen)</span> <span class="comment">//将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值</span></span></span><br><span class="line"><span class="function">e)    string <span class="title">s</span><span class="params">(cstr)</span> <span class="comment">//将C字符串作为s的初值</span></span></span><br><span class="line"><span class="function">f)    string <span class="title">s</span><span class="params">(chars,chars_len)</span> <span class="comment">//将C字符串前chars_len个字符作为字符串s的初值。</span></span></span><br><span class="line"><span class="function">g)    string <span class="title">s</span><span class="params">(num,c)</span> <span class="comment">//生成一个字符串，包含num个c字符</span></span></span><br><span class="line"><span class="function">h)    string <span class="title">s</span><span class="params">(beg,end)</span> <span class="comment">//以区间beg;end(不包含end)内的字符作为字符串s的初值</span></span></span><br><span class="line"><span class="function">i)    s.~<span class="title">string</span><span class="params">()</span> <span class="comment">//销毁所有字符，释放内存</span></span></span><br></pre></td></tr></table></figure>

<p>都很简单，我就不解释了。</p>
<h4 id="2．字符串操作函数"><a href="#2．字符串操作函数" class="headerlink" title="2．字符串操作函数"></a>2．字符串操作函数</h4><p>这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a) =,<span class="built_in">assign</span>()   <span class="comment">//赋以新值</span></span><br><span class="line">b) <span class="built_in">swap</span>()   <span class="comment">//交换两个字符串的内容</span></span><br><span class="line">c) +=,<span class="built_in">append</span>(),<span class="built_in">push_back</span>() <span class="comment">//在尾部添加字符</span></span><br><span class="line">d) <span class="built_in">insert</span>() <span class="comment">//插入字符</span></span><br><span class="line">e) <span class="built_in">erase</span>() <span class="comment">//删除字符</span></span><br><span class="line">f) <span class="built_in">clear</span>() <span class="comment">//删除全部字符</span></span><br><span class="line">g) <span class="built_in">replace</span>() <span class="comment">//替换字符</span></span><br><span class="line">h) + <span class="comment">//串联字符串</span></span><br><span class="line">i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,<span class="built_in">compare</span>()  <span class="comment">//比较字符串</span></span><br><span class="line">j) <span class="built_in">size</span>(),<span class="built_in">length</span>()  <span class="comment">//返回字符数量</span></span><br><span class="line">k) <span class="built_in">max_size</span>() <span class="comment">//返回字符的可能最大个数</span></span><br><span class="line">l) <span class="built_in">empty</span>()  <span class="comment">//判断字符串是否为空</span></span><br><span class="line">m) <span class="built_in">capacity</span>() <span class="comment">//返回重新分配之前的字符容量</span></span><br><span class="line">n) <span class="built_in">reserve</span>() <span class="comment">//保留一定量内存以容纳一定数量的字符</span></span><br><span class="line">o) [ ], <span class="built_in">at</span>() <span class="comment">//存取单一字符</span></span><br><span class="line">p) &gt;&gt;,<span class="built_in">getline</span>() <span class="comment">//从stream读取某值</span></span><br><span class="line">q) &lt;&lt;  <span class="comment">//将谋值写入stream</span></span><br><span class="line">r) <span class="built_in">copy</span>() <span class="comment">//将某值赋值为一个C_string</span></span><br><span class="line">s) <span class="built_in">c_str</span>() <span class="comment">//将内容以C_string返回</span></span><br><span class="line">t) <span class="built_in">data</span>() <span class="comment">//将内容以字符数组形式返回</span></span><br><span class="line">u) <span class="built_in">substr</span>() <span class="comment">//返回某个子字符串</span></span><br><span class="line">v)查找函数</span><br><span class="line">w)<span class="built_in">begin</span>() <span class="built_in">end</span>() <span class="comment">//提供类似STL的迭代器支持</span></span><br><span class="line">x) <span class="built_in">rbegin</span>() <span class="built_in">rend</span>() <span class="comment">//逆向迭代器</span></span><br><span class="line">y) <span class="built_in">get_allocator</span>() <span class="comment">//返回配置器</span></span><br></pre></td></tr></table></figure>

<h5 id="2．1-C-字符串和C字符串的转换"><a href="#2．1-C-字符串和C字符串的转换" class="headerlink" title="2．1 C++字符串和C字符串的转换"></a>2．1 C++字符串和C字符串的转换</h5><p>C++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\0’。c_str()返回一个以‘\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string 或字符数组内。C++字符串并不以’\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。</p>
<h5 id="2．2-大小和容量函数"><a href="#2．2-大小和容量函数" class="headerlink" title="2．2 大小和容量函数"></a>2．2 大小和容量函数</h5><p> 一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。 b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。</p>
<p>还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数 Connect(char*,char*)），但别人的函数参数用的是char<em>形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char</em>,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char<em>上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char</em>上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。</p>
<h5 id="2．3元素存取"><a href="#2．3元素存取" class="headerlink" title="2．3元素存取"></a>2．3元素存取</h5><p> 我们可以使用下标操作符[] 和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引 0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出 out_of_range异常。 有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\0’。其他的各种情况，a.length()索引都是无效的。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string <span class="title">Cstr</span><span class="params">(“<span class="type">const</span> string”)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">Str</span><span class="params">(“string”)</span></span>;</span><br><span class="line"></span><br><span class="line">Str[<span class="number">3</span>];    <span class="comment">//ok</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">3</span>);  <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">Str[<span class="number">100</span>]; <span class="comment">//未定义的行为</span></span><br><span class="line">Str.<span class="built_in">at</span>(<span class="number">100</span>);  <span class="comment">//throw out_of_range</span></span><br><span class="line"></span><br><span class="line">Str[Str.<span class="built_in">length</span>()]  <span class="comment">//未定义行为</span></span><br><span class="line">Cstr[Cstr.<span class="built_in">length</span>()] <span class="comment">//返回 ‘\0’</span></span><br><span class="line">Str.<span class="built_in">at</span>(Str.<span class="built_in">length</span>());<span class="comment">//throw out_of_range</span></span><br><span class="line">Cstr.<span class="built_in">at</span>(Cstr.<span class="built_in">length</span>()) <span class="comment">////throw out_of_range</span></span><br></pre></td></tr></table></figure>

<p>我不赞成类似于下面的引用或指针赋值： <code>char&amp; r=s[2]; char* p= &amp;s[3];</code></p>
<p>因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。</p>
<h5 id="2．4比较函数"><a href="#2．4比较函数" class="headerlink" title="2．4比较函数"></a>2．4比较函数</h5><p> C++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string(“aaaa”) &lt;string(aaaaa)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(“abcd”)</span></span>;</span><br><span class="line">s.<span class="built_in">compare</span>(“abcd”); <span class="comment">//返回0</span></span><br><span class="line">s.<span class="built_in">compare</span>(“dcba”); <span class="comment">//返回一个小于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(“ab”); <span class="comment">//返回大于0的值</span></span><br><span class="line">s.<span class="built_in">compare</span>(s); <span class="comment">//相等</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">0</span>,<span class="number">2</span>,s,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">//用”ab”和”cd”进行比较 小于零</span></span><br><span class="line">s.<span class="built_in">compare</span>(<span class="number">1</span>,<span class="number">2</span>,”bcx”,<span class="number">2</span>); <span class="comment">//用”bc”和”bc”比较。</span></span><br></pre></td></tr></table></figure>

<p>怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？你重修吧！</p>
<h5 id="2．5-更改内容"><a href="#2．5-更改内容" class="headerlink" title="2．5 更改内容"></a>2．5 更改内容</h5><p> 这在字符串的操作中占了很大一部分。 首先讲赋值，第一个赋值方法当然是使用操作符&#x3D;，新值可以是string(如：s&#x3D;ns) 、c_string(如：s&#x3D;”gaint”)甚至单一字符（如：s&#x3D;’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">assign</span>(str); <span class="comment">//直接</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//如果str是”iamangel” 就是把”ama”赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(str,<span class="number">2</span>,string::npos);<span class="comment">//把字符串str从索引值2开始到结尾赋给s</span></span><br><span class="line">s.<span class="built_in">assign</span>(“gaint”); <span class="comment">//不说</span></span><br><span class="line">s.<span class="built_in">assign</span>(“nico”,<span class="number">5</span>);<span class="comment">//把’n’ ‘I’ ‘c’ ‘o’ ‘\0’赋给字符串</span></span><br><span class="line">s.<span class="built_in">assign</span>(<span class="number">5</span>,’x’);<span class="comment">//把五个x赋给字符串</span></span><br></pre></td></tr></table></figure>

<p>把字符串清空的方法有三个：s&#x3D;””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。 string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。 先说增加字符（这里说的增加是在尾巴上），函数有 +&#x3D;、append()、push_back()。举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">s+=str;<span class="comment">//加个字符串</span></span><br><span class="line">s+=”my name is jiayp”;<span class="comment">//加个C字符串</span></span><br><span class="line">s+=’a’;<span class="comment">//加个字符</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(str);</span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//不解释了 同前面的函数参数assign的解释</span></span><br><span class="line">s.<span class="built_in">append</span>(str,<span class="number">2</span>,string::npos)<span class="comment">//不解释了</span></span><br><span class="line"></span><br><span class="line">s.<span class="built_in">append</span>(“my name is jiayp”);</span><br><span class="line">s.<span class="built_in">append</span>(“nico”,<span class="number">5</span>);</span><br><span class="line">s.<span class="built_in">append</span>(<span class="number">5</span>,’x’);</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">push_back</span>(‘a’);<span class="comment">//这个函数只能增加单个字符 对STL熟悉的理解起来很简单</span></span><br></pre></td></tr></table></figure>

<p>也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">insert</span>(<span class="number">0</span>,”my name”);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>,str);</span><br></pre></td></tr></table></figure>

<p>这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：<code>insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)</code>。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。 删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s=”il8n”;</span><br><span class="line">s.<span class="built_in">replace</span>(<span class="number">1</span>,<span class="number">2</span>,”nternationalizatio”);<span class="comment">//从索引1开始的2个替换成后面的C_string</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">13</span>);<span class="comment">//从索引13开始往后全删除</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">7</span>,<span class="number">5</span>);<span class="comment">//从索引7开始往后删5个</span></span><br></pre></td></tr></table></figure>

<p>2．6提取子串和字符串连接</p>
<p>题取子串的函数是：substr(),形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">substr</span>();<span class="comment">//返回s的全部内容</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">11</span>);<span class="comment">//从索引11往后的子串</span></span><br><span class="line">s.<span class="built_in">substr</span>(<span class="number">5</span>,<span class="number">6</span>);<span class="comment">//从索引5开始6个字符</span></span><br></pre></td></tr></table></figure>

<p>把两个字符串结合起来的函数是+。（谁不明白请致电120）</p>
<p>2．7输入输出操作 1．» 从输入流读取一个string。 2．« 把一个string写入输出流。 另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。</p>
<p>2．8搜索与查找 查找函数很多，功能也很强大，包括了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>()</span><br><span class="line"><span class="built_in">rfind</span>()</span><br><span class="line"><span class="built_in">find_first_of</span>()</span><br><span class="line"><span class="built_in">find_last_of</span>()</span><br><span class="line"><span class="built_in">find_first_not_of</span>()</span><br><span class="line"><span class="built_in">find_last_not_of</span>()</span><br></pre></td></tr></table></figure>

<p>这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下： 第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说 不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。 最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)&#x3D;&#x3D;string::npos)）。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2021/08/04/cpp-fstream/">prev</a><a class="next" href="/2021/07/21/stl_use/">next</a></div><div class="copyright"><p>&copy; 2022 <a href="https://q.billma.top">BillMa</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>