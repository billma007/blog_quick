<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bill Ma&#39;s Blog(smarter....)</title>
  
  <subtitle>A snarter blog</subtitle>
  <link href="https://q.billma.top/atom.xml" rel="self"/>
  
  <link href="https://q.billma.top/"/>
  <updated>2022-02-26T09:51:13.375Z</updated>
  <id>https://q.billma.top/</id>
  
  <author>
    <name>BillMa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乌克兰和俄罗斯的恩怨与胆量以及其他国家的反映</title>
    <link href="https://q.billma.top/2022/02/24/ru-uk-war/"/>
    <id>https://q.billma.top/2022/02/24/ru-uk-war/</id>
    <published>2022-02-24T09:19:34.000Z</published>
    <updated>2022-02-26T09:51:13.375Z</updated>
    
    <content type="html"><![CDATA[<p>近期乌克兰与俄罗斯的战斗已经打响，并且已经影响到了全球股价与油价。而且，美国英国德国等国家纷纷提出了对俄罗斯的制裁措施。但是，情况会不会变得更糟呢？为什么他们俩会打起来呢？</p><h2 id="1-最新时局分析"><a href="#1-最新时局分析" class="headerlink" title="1.最新时局分析"></a>1.最新时局分析</h2><p>这一部分代表了我对时局的最新分析，会随着时间而更新，已经过时的内容及时判断错的也不会删除。时局爱好者，非专家，分析内容仅主观判断，仅供参考。</p><h3 id="2022年2月24日下午-俄罗斯正式向乌克兰进军"><a href="#2022年2月24日下午-俄罗斯正式向乌克兰进军" class="headerlink" title="2022年2月24日下午 俄罗斯正式向乌克兰进军"></a>2022年2月24日下午 俄罗斯正式向乌克兰进军</h3><h4 id="美国不可能向乌克兰派兵"><a href="#美国不可能向乌克兰派兵" class="headerlink" title="美国不可能向乌克兰派兵"></a>美国不可能向乌克兰派兵</h4><h5 id="1-一旦美国出兵，性质就不一样了"><a href="#1-一旦美国出兵，性质就不一样了" class="headerlink" title="1.一旦美国出兵，性质就不一样了"></a>1.一旦美国出兵，性质就不一样了</h5><p>上世纪中期，美苏的冷战处于水深火热之中，双方的军备竞赛已经到了水深火热的地步，双方制造的武器甚至可以毁灭世界；最严重的情况是双方炮对炮，一触即发；冷战的结果甚至是使世界最大的国家解体。</p><p>两点：1.冷战的后果已经十分严重了，万一上次是苏联解体，这回就是美国的经济危机呢？资本主义下的市场经济本身就是脆弱的，在后布雷顿森林体系下，万一美国经济塌了，全球经济体系就得垮塌。不仅如此，美国虽然很强大，但是俄罗斯的重型武装不仅会重创美国，也会重创世界。</p><p>2.上世纪的冷战都已经这么严重了，都没有爆发美俄战争；现在就一个乌克兰打仗，美国怎么会因为这点屁事就和俄罗斯开打？</p><h5 id="2-俄乌矛盾是两国矛盾，美国此时干涉那不就是毁了自己名声？"><a href="#2-俄乌矛盾是两国矛盾，美国此时干涉那不就是毁了自己名声？" class="headerlink" title="2.俄乌矛盾是两国矛盾，美国此时干涉那不就是毁了自己名声？"></a>2.俄乌矛盾是两国矛盾，美国此时干涉那不就是毁了自己名声？</h5><p>去年8月，美国刚从阿富汗撤军。回顾20年前，2001年乔治布什宣战的时候，意气风发；可是现在布什的名声已经因为阿富汗彻底拉跨；伊拉克和叙利亚也是一样。美国现在刚从阿富汗撤军，元气还没恢复，不能也不可能参加大规模战争。</p><h5 id="3-打的过，但不值得"><a href="#3-打的过，但不值得" class="headerlink" title="3.打的过，但不值得"></a>3.打的过，但不值得</h5><p>全世界只有美国能打得过俄罗斯，但是俄罗斯不是好打的。这又不是阿富汗，只有塔利班（更何况塔利班他也没打过）；这是俄罗斯，一旦与俄罗斯开打，一定会杀敌一千自损八百，拜登也就是自讨苦吃。</p><h5 id="4-前提：乌克兰还没加入北约！"><a href="#4-前提：乌克兰还没加入北约！" class="headerlink" title="4.前提：乌克兰还没加入北约！"></a>4.前提：<em><strong>乌克兰还没加入北约</strong></em>！</h5><p>很早以前，乌克兰入北约便提上了进程。但是2013年11月，乌克兰时任总统亚努科维奇放弃了欧盟的经济协议，引发了国内长达3个月的反政府游行示威，<strong>奥巴马明确表示介入了该游行</strong>。后来，乌克兰加入北约进程加速。然而，由于俄罗斯的反对，东扩还是没有实现。如果俄罗斯入侵某北约国家，美国可能还会认为其侵犯了北约领土而出兵（本来美国在北约国家也有驻军），但现在，乌克兰<strong>不是北约成员</strong>，所以美国最多谴责一下俄罗斯，经济支持一下，要想进一步的援助是不可能的。</p><h3 id="2-2022年2月26日下午-俄罗斯逼近基辅"><a href="#2-2022年2月26日下午-俄罗斯逼近基辅" class="headerlink" title="2.2022年2月26日下午 俄罗斯逼近基辅"></a>2.2022年2月26日下午 俄罗斯逼近基辅</h3><h4 id="俄罗斯不会侵占乌克兰"><a href="#俄罗斯不会侵占乌克兰" class="headerlink" title="俄罗斯不会侵占乌克兰"></a>俄罗斯不会侵占乌克兰</h4><p>很简单，一个是目前的全球政治环境不允许，还有一个就是当时苏联解体的时候已经把乌克兰分出去了，现在也不会要回来；还有就是乌克兰普遍反俄，现在强制拿回来不得人心。还有一个最重要的就是这个战争的根本原因是：防止乌克兰成为北约致使北约与俄罗斯接壤。俄罗斯吞并了乌克兰，那不就真的接壤了吗？</p><h4 id="俄乌战争与中国"><a href="#俄乌战争与中国" class="headerlink" title="俄乌战争与中国"></a>俄乌战争与中国</h4><p>现在乌克兰因为众所周知的原因开始蔓延反华情绪。西方想我们表态，想我们也制裁俄罗斯，看到我们现在的态度，他们可能会搞些小动作，肯定会有一部人受到了误导出现了反华情绪，站在我们的立场也很难，不可能表明支持哪一方，更不可能帮助哪一方。</p><h2 id="2-俄方装备"><a href="#2-俄方装备" class="headerlink" title="2.俄方装备"></a>2.俄方装备</h2><p>大概看了下，俄方大概派了T72b3，T90，T14这几个型号的主战坦克，步兵貌似大范围是AK74。T14刚研制没几年，T90，T72b3是目前俄军的大面积装备的坦克；AK74俄军现役步枪，貌似还有AK100一族的；大概就是乌克兰不投降，俄军不会停，因为俄军不是把还可以用的旧型号的坦克拿出来。以及库存巨多的AK47，不投降45万乌军估计得全吹了；说实话，我没想到会上T14；不仅如此，就目前发的视频，T90巨多。</p><h2 id="未完待续，持续更新"><a href="#未完待续，持续更新" class="headerlink" title="未完待续，持续更新"></a>未完待续，持续更新</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期乌克兰与俄罗斯的战斗已经打响，并且已经影响到了全球股价与油价。而且，美国英国德国等国家纷纷提出了对俄罗斯的制裁措施。但是，情况会不会变得更糟呢？为什么他们俩会打起来呢？&lt;/p&gt;
&lt;h2 id=&quot;1-最新时局分析&quot;&gt;&lt;a href=&quot;#1-最新时局分析&quot; class=&quot;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++20与C++23关于Module的引入</title>
    <link href="https://q.billma.top/2022/02/22/cpp23-module/"/>
    <id>https://q.billma.top/2022/02/22/cpp23-module/</id>
    <published>2022-02-22T12:27:37.000Z</published>
    <updated>2022-02-22T13:24:04.219Z</updated>
    
    <content type="html"><![CDATA[<h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>几天前，C++20 草案已经获得了标准委员会的全票通过，C++2a 草案讨论的几个重要内容，比如“概念（concept）”、“范围库（Ranges Library）”、“协程（Coroutines）” 和 “模块（Module）” 都加到 C++20 的标准中了，剩下的就是看编译器厂商的支持速度了。目前看 CLANG 、GCC 和 Microsoft 是比较积极的三家，语言特性和库支持的最快的是 GCC，其次是 CLANG 和 Visual C++，估计最快到年底就能看到支持全部 C++ 20 特性的编译器了。</p><p>毫无疑问，在目前主流的编程语言中，C++ 是最难掌握的编程语言，没有之一。C++ 的内容繁杂，知识点多，当然，“坑”也多，非常适合出题考试。正因如此，C++才被认定为了中国计算机协会唯一信息学奥林匹克竞赛的语言（还可以选C，但差不多）除了对初学者门槛太高，传统的 C++ 语言特性上支持的也很弱，与其他编程语言相比，做同样的功能，C++ 往往需要写更多的代码。不过从 C++11 开始，一直到 C++17，这种情况开始有了明显地改善，各种之前被 C++ 社区讽刺为“语法糖”的语言特性逐步被添加到 C++ 语言规范中，比如 lambda 表达式，比如基于范围的 for 循环。应该说，这都是被 Python “逼”的。Python除了运行较C++慢以外，语言简练，格式清爽，扩展性强，早就超越了C++。身为一个竞赛选手，虽然竞赛语言是C++，但是在业余程序设计上，我还是更喜欢使用Python.</p><p>所以，C++20便引入了Module（模块）。我第一次看到这玩意的时候，我草，import不是Python的东西吗？怎么被C++用了？后来我仔细阅读了相关文档，才懂得了更多。</p><h2 id="老毛病"><a href="#老毛病" class="headerlink" title="老毛病"></a>老毛病</h2><p><strong>此处引用CSDN博主<a href="https://blog.csdn.net/orbit/article/details/108680567">「吹泡泡的小猫」</a>的文章进行说明，讲得实在是太好了</strong></p><h3 id="1-头文件和源文件"><a href="#1-头文件和源文件" class="headerlink" title="1.头文件和源文件"></a>1.头文件和源文件</h3><p>C&#x2F;C++ 语言使用头文件和源文件分离方式迫使程序员养成接口与实现分离的设计习惯的哲学实验事实上是失败了，除了极少的优质项目，大部分的C++项目的源代码组织并没有有效地实施这个原则，反而引入了一大堆头文件难题，extern关键字的“巧用”更是让这个问题雪上加霜。对初学者来说，找不到头文件是最大的“痛”。它就在那儿，为什么编译器就是“视而不见”？那是因为你的包含路径设置不正确，什么绝对路径，什么相对路径，让很多还没入门的初学者过早地体会了“码”生的艰难。学习 C++，从入门到放弃，也许 include 一个“永远”找不到的头文件就够了。</p><h3 id="2-剪不断，理还乱"><a href="#2-剪不断，理还乱" class="headerlink" title="2.剪不断，理还乱"></a>2.剪不断，理还乱</h3><p>对于一个大一点的项目来说，头文件之间那种“剪不断、理还乱”的关系最让人头疼不已。头文件之间的循环依赖、互相依赖，你中有我，我中有你。“要用这个接口，只要包含那个叫 A 的头文件就行了，easy！”，你的同事们是否都这样信誓旦旦地跟你说过类似的话？大部分情况下你会发现这个叫 A 的头文件并不单纯，它可能还有“七大姑八大姨”分别位于不同的代码目录中，如果你不设置好头文件的搜索路径，编译器会告诉你人生有多难。当 Java 的程序员在软件架构层面上考虑对象之间的依赖关系时，C++ 的程序员还在为了解决编译问题而试着调整各个头文件的包含顺序，唉，说多了都是泪。</p><h3 id="3-编译速度"><a href="#3-编译速度" class="headerlink" title="3.编译速度"></a>3.编译速度</h3><p>C++ 的另一个痛点就是编译速度了。相对于 C++ 的各种“难用”，编译速度太慢才是 C++ 最大的诟病。本人曾在一个大型 C 语言项目中引入了一个 C++ 模块，编译的时候编译器对 C 的源文件和 C++ 的源文件的处理速度明显不在一个数量级上。GCC 在编译 C 语言的源文件的时候，处理速度飞起，输出信息刷屏的速度眼花缭乱。但是在处理 C++ 的源文件的时候，基本上就是以每秒 1 - 2 个这样的目视可见的速度推进。C++ 因为引入了泛型和模板库，支持重载，这使得它的预处理需要做很多事情，慢也是必然的。但是对于一个大型项目来说，这种慢会严重拖累自动化编译、测试和部署的速度，换句话说，就是不“敏捷”。</p><p>话不多说，接下来进入正题。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>现在看看 C++20 的 Module 能给我们带来什么。在 Modernes C++ 网站上，可以窥得一些细节，C++20 的 Module 承诺了五个目标：</p><h3 id="更快的编译时间（Faster-compile-times）"><a href="#更快的编译时间（Faster-compile-times）" class="headerlink" title="更快的编译时间（Faster compile times）"></a>更快的编译时间（Faster compile times）</h3><p>C++ 的编译器在处理一个源代码文件的时候，首先要做的就是用相应的头文件的内容替换 #include 预编译指令。这就存在一个问题，对每一个源代码文件编译器都要重复一遍内容替换，这会占用大量的处理器时间。替换完的源文件长度也会膨胀数倍，一个源代码文件的处理速度不仅要看这个文件中有多少代码，还要看它包含了多少头文件。使用 Module，只需要 #import 一次（编译器只需要对导入的 Module 做一次解析处理），就可以在所有的源代码文件中使用，没有头文件的替换动作，也不需要重复解析处理 Module，这对编译时间将是一个巨大的优化。</p><h3 id="宏的隔离（Isolation-of-macros）"><a href="#宏的隔离（Isolation-of-macros）" class="headerlink" title="宏的隔离（Isolation of macros）"></a>宏的隔离（Isolation of macros）</h3><p>只要你使用 C++ 的时间足够长，你就会碰到这样的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XXXX  ...</span></span><br></pre></td></tr></table></figure><p>初次看到这样多此一举的代码，心里肯定会想这是什么鬼？其实见怪不怪，肯定是某个家伙的也定义了一个同样名为 XXXX 的宏，只是值不一样而已。对于同名的宏，如果值也一样，编译器一般“睁一只眼闭一只眼”就放过去了。但是如果值不一样，大多数编译器的默认选项也只是提示一个编译告警，如果你碰巧忽略了这个编译告警，等待你的很可能是痛苦的 Debug 过程。菜鸟们经常抱怨：“我定义的宏的值明明是 5，为什么赋值给变量后变成这个奇怪的值？” 那是因为别人也定义了同名的宏，并且恰巧头文件处理顺序在你的前面。要么调整头文件的包含顺序，要么用上面那段代码，这就是 C++ 程序员的日常工作内容。Module 的使用，可以缓解这种困惑。首先，从语义上讲，可以用 module_name.XXXX 来隔离宏，其次，Module 只需要导入一次，同名宏的先后关系与只与导入顺序一致，不会因为头文件的包含顺序混乱让对某个宏的值你摸不着头脑。</p><h3 id="表达代码的逻辑结构（Express-the-logical-structure-of-the-code）"><a href="#表达代码的逻辑结构（Express-the-logical-structure-of-the-code）" class="headerlink" title="表达代码的逻辑结构（Express the logical structure of the code）"></a>表达代码的逻辑结构（Express the logical structure of the code）</h3><p>从设计层面上考虑，头文件其实包含了过多的实现细节，并不适合向外展示，Module 则很好的规避了这一点。首先，作为一个二进制的包，你不想展示给用户的内容，都可以隐藏起来，只将必要的部分标记为 export 即可。其次，你可以按照代码的实现逻辑设计各个 Module，它们可以自由组合形成不同功能的逻辑包提供给客户，这都比给客户一堆平面表达的头文件，然后让客户自己选择组合使用更能满足客户的需求。</p><h3 id="让头文件成为“过去式”（Make-header-files-superfluous）"><a href="#让头文件成为“过去式”（Make-header-files-superfluous）" class="headerlink" title="让头文件成为“过去式”（Make header files superfluous）"></a>让头文件成为“过去式”（Make header files superfluous）</h3><p>一个 C++ 项目只要对同一使用的 Module 管理规范，可彻底解决各种包含路径问题。当你想使用某个接口的时候，只要 #import A就行了，再也不用关心该死的头文件搜索路径了，谁说这不“香”呢？毫无疑问，有了 Module，再也不会有人走回头路用头文件了。话又说回来，这也让 C++ 的代码与 Java 代码的相似度又增进了一层，搞不好以后要看源代码文件的扩展名才能区分。</p><h3 id="摆脱丑陋的宏环境（Get-rid-of-an-ugly-macro-workarounds）"><a href="#摆脱丑陋的宏环境（Get-rid-of-an-ugly-macro-workarounds）" class="headerlink" title="摆脱丑陋的宏环境（Get rid of an ugly macro workarounds）"></a>摆脱丑陋的宏环境（Get rid of an ugly macro workarounds）</h3><p>前面讲过，C++ 的编译器在对 #include 指令包含的头文件的处理方式是原地展开替换，假如一个源文件包含了头文件 A 和头文件 B，而头文件 B 又不巧间接包含了头文件 A（这种情况在一个大型的 C++ 项目中几乎是常态），那么 A 就会在这个源文件中被展开替换两次。确实是这样的，编译器不仅浪费时间做了展开替换，还会抱怨符号重复定义的错误。所以你会看到每个头文件几乎都是这样用宏环境包裹着自己：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THIS_HEAD_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THIS_HEAD_FILE_H</span></span><br><span class="line">​</span><br><span class="line">.....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THIS_HEAD_FILE_H</span></span></span><br></pre></td></tr></table></figure><p>也许看的时间长了，觉得这样的代码很规范，其实这是一种多么无奈的选择，还是上面那句话：不用头文件，就不用再浪费时间给每个头文件写这种宏环境了。</p><h2 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h2><p>1 实现一个最简单的module<br>module_hello.cppm：定义一个完整的hello模块，并导出一个say_hello_to方法给外部使用。当前各编译器并未规定模块文件的后缀，本文统一使用”.cppm”后缀名。”.cppm”文件有一个专用名称”模块接口文件”，值得注意的是，该文件不光可以声明实体，也可定义实体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> std::string_view&amp; something)</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>&lt;&lt;something&lt;&lt;<span class="string">&quot; !&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数中可以直接使用hello模块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello_to</span>(std::string_view&#123;<span class="string">&quot;Netease&quot;</span>&#125;);</span><br><span class="line">    <span class="built_in">internal_helper</span>();<span class="comment">//error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译脚本如下，需要先编译module_hello.cppm生成一个pcm文件（module缓存文件），该文件包含了hello模块导出的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#buildfile.sh</span></span><br><span class="line">CXX=<span class="string">&quot;clang -fmodules-ts -std=c++2a&quot;</span></span><br><span class="line">$CXX -o module_hello.pcm --precompile -x c++-<span class="keyword">module</span> module_hello.cppm</span><br><span class="line">$CXX -o hello -fprebuilt-<span class="keyword">module</span>-path=. main.cpp hello.cpp</span><br></pre></td></tr></table></figure><p>以上代码有以下细节需要注意：</p><blockquote><p>module hello; 声明了一个模块，前面加一个export，则意味着当前文件是一个模块接口文件（module interface file），只有在模块接口文件中可以导出实体（变量、函数、类、namespace等）。一个模块至少有一个模块接口文件、模块接口文件可以只放实体声明，也可以放实体定义。<br>想要导出一个函数，在函数定义&#x2F;声明前加一个export关键字即可。<br>import hello；不需加尖括号。且不同于include，import 后跟的不是文件名，而是模块名（文件名为module_hello.cpp）。编译器并未强制模块名必须与文件名一致。<br>import的模块不具有传递性。hello模块包含了string_view，但是main函数在使用hello模块前，依然需要再import <string_view>;<br>模块中的import声明需要放在模块声明之后、模块内部其他实体声明之前。即：import ;必须放在export module hello;之后、void internal_helper()之前<br>编译时需要先编译基础的模块，再编译上层模块。buildfile.sh中先将module_hello编译为pcm，再编译main。<br>module_hello.cppm中并未包含say_hello_to函数的声明，而是直接定义实现。编译器会将函数原型等信息放在module_hello.pcm中。</p></blockquote><h3 id="2-接口与实现分离"><a href="#2-接口与实现分离" class="headerlink" title="2 接口与实现分离"></a>2 接口与实现分离</h3><p>当模块的规模变大、接口变多之后，将所有的实体定义都放在模块接口文件中会非常不利于代码的维护，C++20的模块机制还支持接口与实现分离。<br>module_hello.cppm：我们假设say_hello_to、func_a、func_b等函数十分复杂，.cppm文件中只包含函数的声明（square方法是个例外，它是函数模板，只能定义在.cppm中，不能分离式编译）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> string_view&amp;)</span></span>;</span><br><span class="line"><span class="comment">//缩写的函数模板，C++20新糖果</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">auto</span> <span class="title">square</span><span class="params">(<span class="type">const</span> <span class="keyword">auto</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>module_hello.cpp：给出hello模块的各个函数声明对应的实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> string_view&amp;)</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>&lt;&lt;something&lt;&lt;<span class="string">&quot; !&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码有以下细节需要注意：</p><blockquote><p>整个hello模块分成了 module_hello.cppm和module_hello.cpp两个文件，前者是模块接口文件(module声明前有export关键字)，后者是模块实现文件（module implementation file）。当前各大编译器并未规定模块接口文件的后缀必须是cppm。<br>模块实现文件中不能export任何实体。<br>函数模板，比如代码中的square函数，定义必须放在模块接口文件中，使用auto返回值的函数，定义也必须放在模块接口文件。</p></blockquote><h3 id="3-可见性控制"><a href="#3-可见性控制" class="headerlink" title="3 可见性控制"></a>3 可见性控制</h3><p>在模块的最开始的例子中，我们就提到了模块的import不具有传递性：<br>main函数使用hello模块的时候必须import <string_view>;。<br>如果想让 hello模块中的string_view模块透给使用者，需使用export import显式声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>hello模块显示导出string_view后，main文件中便无需再包含string_view了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="comment">//无需再import &lt;string_view&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello_to</span>(std::string_view&#123;<span class="string">&quot;Netease&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4 子模块（submodule）<br>当模块变得再大一些，仅仅是将模块的接口与实现拆分也有点力不从心：模块实现文件会变得非常大，不便于代码的维护。C++20的模块机制支持子模块。<br>这次module_hello.cppm文件不再定义、声明任何函数，而是仅仅显式导出hello.sub_a、hello.sub_b两个子模块，外部需要的方法都由上述两个子模块定义，module_hello.cppm充当一个“汇总”的角色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_a;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_b;</span><br></pre></td></tr></table></figure><p>子模块module hello.sub_a采用了接口与实现分离的定义方式：“.cppm”中给出定义，“.cpp”中给出实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_a.cppm（子模块a的接口文件）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_a;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_a.cpp（子模块a的实现文件）</span></span><br><span class="line"><span class="keyword">module</span> hello.sub_a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module hello.sub_b同上，不再赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_b.cppm（子模块b的接口文件）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_b;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_b.cpp（子模块b的实现文件）</span></span><br><span class="line"><span class="keyword">module</span> hello.sub_b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，hello模块的接口和实现文件各自被拆分到了两个文件中。值得注意的是，C++20的子模块是一种“模拟机制”，模块hello.sub_b是一个完整的模块，中间的点并不代表语法上的从属关系，不同于函数名、变量名等标识符的命名规则，模块的命名规则中允许点存在于模块名字当中。点只是从逻辑语义上帮助程序员理解模块间的逻辑关系。</p><h3 id="5-module-partition"><a href="#5-module-partition" class="headerlink" title="5 module partition"></a>5 module partition</h3><p>除了子模块之外，处理复杂模块的机制还有module partition</p><p>module partition分为两种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> implementation partition</span><br><span class="line"><span class="keyword">module</span> interface partition</span><br></pre></td></tr></table></figure><p>module implementation partition可以通俗的理解为：将模块的实现文件拆分成多个。<br>module_hello.cppm文件：给出模块的声明、导出函数的声明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>模块的一部分实现代码拆分到module_hello_partition_internal.cpp文件，该文件实现了一个内部方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_internal.cpp(parititon internal的实现文件，无需给出接口文件)</span></span><br><span class="line"><span class="keyword">module</span> hello:internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块的另一部分实现拆分到module_hello.cpp文件，该文件实现了func_a、func_b，同时引用了内部方法internal_helper。（func_a、func_b当然也可以拆分到两个cpp文件中）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> :internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是， 模块内部import 一个module partition时，不能import hello:internal;而是直接import :internal; 。</p><p>module interface partition可以理解为模块声明拆分到多个文件中。module implementation partition的例子中，函数声明只集中在一个文件中，module interface partition可以将这些声明拆分到多个文件。</p><p>首先定义一个内部helper：internal_helper</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_internal.cpp(parititon internal的实现文件，无需给出接口文件)</span></span><br><span class="line"><span class="keyword">module</span> hello:internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello模块的a部分采用声明+定义合一的方式，定义在module_hello_partition_a.cppm中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_a.cppm（partition a的声明+实现）</span></span><br><span class="line"><span class="keyword">export</span> hello:partition_a;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>hello模块的b部分采用声明+定义分离的方式，module_hello_partition_b.cppm只做声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_b.cppm（partition b的声明）</span></span><br><span class="line"><span class="keyword">export</span> hello:partition_b;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module_hello_partition_b.cpp给出hello模块的b部分对应的实现：</span><br><span class="line"></span><br><span class="line"><span class="comment">//module_hello_partition_b.cpp（partition b的实现）</span></span><br><span class="line"><span class="keyword">module</span> hello;<span class="comment">//不能使用module hello:partition_b!!!!!!</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module_hello.cppm再次充当了”汇总“的角色，将模块的a部分+b部分导出给外部使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm //primary module interface file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">export</span> :partition_a;</span><br><span class="line"><span class="keyword">export</span> :partition_b;</span><br><span class="line"><span class="comment">//export :internal; //编译错误！！！！</span></span><br></pre></td></tr></table></figure><p>module implementation partition的使用方式较为直观，相当于我们平时编程中“一个头文件声明多个cpp实现”这种情况。module interface partition有点类似于submodule机制，但语法上有较多差异：</p><p>module_hello_partition_b.cpp 第一行不能使用 import hello:partition_b;虽然这样看上去更符合直觉，但是，就是不允许。一个partition name只能创建一个文件<br>每个module partition interface最终必须被primary module interface file导出，不能遗漏。<br>primary module interface file 不能导出module implementation file，只能导出module interface file。故在module_hello.cppm中export :internal;是错误的。<br>同样作为处理大模块的机制，module partition与子模块最本质的区别在于：<br>子模块可以独立的被外部使用者import，而module partition只在模块内部可见，外部无法使用。</p><h3 id="6-全局模块片段（Global-module-fragments）"><a href="#6-全局模块片段（Global-module-fragments）" class="headerlink" title="6 全局模块片段（Global module fragments）"></a>6 全局模块片段（Global module fragments）</h3><p>C++20之前有大量的不支持模块的代码、头文件，这些代码实际被隐式的当作全局模块片段处理，模块代码与这些片段交互方式如下：</p><p>module; &#x2F;&#x2F;开启了一个全局模块片段，#include必须出现在该行之后、模块声明之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span><span class="comment">//include一个非模块化的文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，由于标准库的大多数头文件尚未模块化（VS模块化了部分头文件），2.1～2.5章节的代码在当前编译器环境下(Clang12)是不能直接编译通过的——当前尚不能直接import &lt; iostream &gt; 等模块，通全局模块段则可以进行方便的过渡,另一个过渡方案便是下一节所介绍的module map。</p><h3 id="7-module-map"><a href="#7-module-map" class="headerlink" title="7 module map"></a>7 module map</h3><p>module map机制可以将普通的头文件映射成module，进而可以使旧的代码吃到module机制的红利。下面便以clang13中的module map机制为例。<br>假设有一个a.h头文件，该头文件历史较久，不支持module：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h 该头文件历史较为久远</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过给Clang编译器定义一个module.modulemap文件,在该文件中可以将头文件映射成模块：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.modulemap</span></span><br><span class="line"><span class="comment">//改造自定义头文件</span></span><br><span class="line"><span class="keyword">module</span> A &#123;</span><br><span class="line">    header <span class="string">&quot;a.h&quot;</span></span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造C库头文件</span></span><br><span class="line"><span class="keyword">module</span> ctype &#123;</span><br><span class="line">    header <span class="string">&quot;ctype.h&quot;</span></span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造C++标准库头文件</span></span><br><span class="line"><span class="keyword">module</span> iostream&#123;</span><br><span class="line">    <span class="keyword">requires</span> cplusplus <span class="comment">//requires cplusplus11 or requires cplusplus17</span></span><br><span class="line">    header <span class="string">&quot;iostream&quot;</span>    </span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> A;</span><br><span class="line"><span class="keyword">import</span> iostream;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_a</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;import iostream&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译脚本需要依次编译A、ctype、iostream三个模块，然后再编译main文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildfile.sh</span></span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o A.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=A</span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o ctype.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=ctype</span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o iostream.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=iostream</span><br><span class="line">clang -cc1 -emit-obj main.cpp -fmodules -fmodule-map-file=<span class="keyword">module</span>.modulemap</span><br><span class="line">-fmodule-file=A=A.pcm</span><br><span class="line">-fmodule-file=iostream=iostream.pcm</span><br></pre></td></tr></table></figure><p>首先使用-fmodule-map-file参数，指定一个module map file，然后通过-fmodule指定map file中定义的module，就可以将头文件编译成pcm。main文件使用A、iostream等模块时，同样需要使用fmodule-map-file参数指定mdule map文件，同时使用-fmodule指定依赖的模块名称。</p><p>注：关于module map机制能够查到的资料较少，有些细节笔者也未能一一查明，例如，通过module map将一个头文件模块化之后，头文件中暴露的宏会如何处理？假如头文件声明的实体的实现分散在多个cpp中，该如何组织modulemap编译？</p><h3 id="8-module-与-namespace"><a href="#8-module-与-namespace" class="headerlink" title="8 module 与 namespace"></a>8 module 与 namespace</h3><p>module与namespace是两个维度的概念，在module中同样可以导出namespace：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">module</span>;</span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> hello&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello::<span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>最后，对比最开始提到的头文件的缺点，模块机制有以下几点优势：</p><blockquote><p>无需重复编译：一个模块的所有接口文件、实现文件，作为一个翻译单元，一次编译后生成pcm，之后遇到import该模块的代码，编译器会从pcm中寻找函数声明等信息。该特性会极大加快C++代码的编译速度。<br>隔离性更好。模块内import的内容，不会泄漏到模块外部，除非显式使用export import声明。<br>顺序无关。import多个模块，无需关心这些模块间的顺序。</p></blockquote><blockquote><p>减少冗余与不一致。小的模块可以直接在单个cppm文件中完成实体的导出、定义。但大的模块依然会把声明、实现拆分到不同文件。</p></blockquote><blockquote><p>子模块、module partition等机制让大模块、超大模块的组织方式更加灵活。</p></blockquote><blockquote><p>全局模块段、module map制使得module与老旧的头文件交互成为可能</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote><p>编译器支持不稳定。尚未有编译器完全支持module的所有特性、clang13支持的module map特性不一定保留到主干版本。</p></blockquote><blockquote><p>编译时需要分析依赖关系、先编译最基础的模块。</p></blockquote><blockquote><p>现有的C++工程需要重新组织pipline，且尚未出现自动化的构建系统，需要人工根据依赖关系组构建脚本，实施难度巨大</p></blockquote><h3 id="module不能做啥？"><a href="#module不能做啥？" class="headerlink" title="module不能做啥？"></a>module不能做啥？</h3><blockquote><p>module不能实现代码的二进制分发。依然需要通过源码分发module</p></blockquote><blockquote><p>pcm文件不能通用，不同编译器的pcm文件不能通用、同一编译器不同参数的pcm不能通用</p></blockquote><blockquote><p>无法自动构建，现阶段需要人工组织构建脚本</p></blockquote><p>编译器如何实现对外隐藏module内部符号的？</p><blockquote><p>在module机制出现之前，符号的链接性分为外部连接性(external linkage，符号可在文件之间共享)、内部链接性(internal linkage，符号只能在文件内部使用),可以通过extern、static等关键字控制一个符号的链接性。<br>module机制引入了模块链接性(module linkage)，符号可在整个模块内部共享(一个模块可能存在多个partition文件)</p></blockquote><blockquote><p>对于模块export的符号，编译器根据现有规则（外部连接性）对符号进行名称修饰(name mangling)<br>对于module内部的符号，统一在符号名称前面添加“_Zw”名称修饰，这样链接器链接时便不会链接到内部符号。</p></blockquote><h3 id="失望之处"><a href="#失望之处" class="headerlink" title="失望之处"></a>失望之处</h3><p>最后，说说C++20 Module 特性让我失望的地方，那就是没有统一语言层面上的包管理器。从标准上看，依然是准备留给编译器厂商或第三方机构做这个事情。这不仅让我想起来 C++ 到现在都没有一个语言层面上的 UI 库，虽然第三方的 UI 库倒是不少，但是基本上处于“生殖隔离”的状态，互不通用，编程方法千差万别，也各有优缺点，常常让 C++ 程序员无所适从。对于包管理器，微软推出了 NuGet，但是由于跟自家的 IDE 捆绑太紧密，并没有得到 C++ 社区的广泛支持。Python 之所以好用，是因为 Python 语言的缔造者和整个 Python 社区共同维护一个统一的包管理器，对各种库提供统一的包装接口，使用简单，学习也简单。从现在开始到 C++23 发布还有不到三年时间，希望 C++ 标准委员会能领导整个社区弄一个统一的包管理器，对各种库提供一致的接口封装，避免出现同一个库有多个 Module 封装版本的情况出现，让 C++ 程序员再次无所适从。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;废话&quot;&gt;&lt;a href=&quot;#废话&quot; class=&quot;headerlink&quot; title=&quot;废话&quot;&gt;&lt;/a&gt;废话&lt;/h2&gt;&lt;p&gt;几天前，C++20 草案已经获得了标准委员会的全票通过，C++2a 草案讨论的几个重要内容，比如“概念（concept）”、“范围库（Ran</summary>
      
    
    
    
    <category term="编程算法" scheme="https://q.billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>转载：新冠大流行和数字资本主义的崛起（文/丹尼尔·科恩（Daniel Cohen））</title>
    <link href="https://q.billma.top/2022/02/06/COVID-19-zbzydjq/"/>
    <id>https://q.billma.top/2022/02/06/COVID-19-zbzydjq/</id>
    <published>2022-02-06T07:18:06.000Z</published>
    <updated>2022-02-06T07:25:31.965Z</updated>
    
    <content type="html"><![CDATA[<p>新冠肺炎疫情的暴发，让面对面的交流接触成为了一种负担甚至是一种可怕的行为。为了让人们远离感染的风险，并防止大面积的感染造成的卫生系统的不堪重负，在许多国家，餐馆、咖啡馆、音乐厅和其他对繁荣的城市文明必不可少的文化设施，被关闭了长达一年之久。生活退回到家庭中，足不出户成为常态。</p><p>　　疫情期间的封锁状态，依靠网络的在线工作场景，无需进入实体店的网上购物体验，在不冒险外出的情况下自娱自乐，最大的赢家是亚马逊、苹果和网飞等公司，它们的市值在新冠危机期间不断地飙升。</p><p>　　事实上，这种所谓的数字资本主义恰恰依赖于减少实体互动和消除面对面会议的现实需要。新冠疫情使许多活动转向互联网的线上活动，例如，医疗问诊实现了远程在线服务。因而，疫情大流行让数字领域的巨头们获得了一个机会，得以对虚拟世界如何影响现实世界，进行一次全方位的实验。</p><p>　　2021年1月20日，德国亚琛市，伯利恒医院的医生与亚琛大学医院的医生通过远程医疗系统，讨论针对新冠患者的治疗方案。</p><p>　　要了解为什么数字经济与保护人们免受面对面互动的需要齐头并进，重读法国经济学家让·富雷斯蒂埃（Jean Fourastié）1948年的开创性著作《二十世纪的伟大希望》（The Great Hope of the Twentieth Century）会有所帮助。富雷斯蒂埃对未来世界进行了乐观的展望：在耕耘土壤的农业社会和与物质打交道的工业社会之后，服务社会中的人类最终将耕耘自己，教育、健康和休闲将成为新世界的核心。</p><p>　　“第三产业文明将灿烂辉煌，一半或四分之三的人口将享受高等教育的优势。”富雷斯蒂埃写道，“在几代人之内，即使是低技能工作的主动性，以及交通工具和休闲活动的多样性，都会有利于人类的个人主义倾向。”</p><p>　　因此，他得出的结论是，“这样的时代即将到来：历史已经进步到足以让人类合理地努力阐述新时代的哲学，并在一个不那么压抑的黑暗中努力实现戏剧性的诞生。机器要将人类从‘非生命体’就可自主完成的劳动中解放出来，把我们引向只有人类才能完成的工作：智力培养和道德提升。”</p><p>　　转型成为一个“人性化”社会这一观点得到了诸多人的评论。在1930年代成为法国首位社会党总理的利昂·布卢姆（Léon Blum）就是其中之一，他在此书出版时写下了一段精彩且直指核心问题的评论。此书预测到了一个没有经济增长的世界。富雷斯蒂埃确信服务型社会不会受制于科技，而科技最终会让经济增长消失。如果一个人所能出售的商品是他与别人相处的时间，那么经济增长在理论上受限于人拥有的时间。</p><p>　　疫情期间，亚马逊、网飞等公司成了大赢家。</p><p>　　这就导致了经济学家所说的“鲍莫尔成本病”，这是由威廉·鲍莫尔（William J. Baumol）和威廉·鲍文（William G. Bowen）在1960年代创造的经济术语。无论是医疗、教育还是表演行业，相当于鲍莫尔提出的两部门非均衡增长模型中的停滞部门，这是服务行业显著特征，靠的是人的一对一或一对多的服务，劳动效率难以提高。</p><p>　　如果没有数字技术，所有服务行业的从业人员都将缺少规模经济，从而无法让某个供应商接触到越来越多的客户。规模经济的概念，即企业可以在保持成本不变或只增加一点成本的情况下增加产量，是经济分析的基础。它让一家企业进入一个良性循环：客户群越大，其业务就越繁荣。否则，超过一定规模，公司就会陷入停滞。</p><p>　　服务业为了获得最大的经济利益，需要能使产品受众群体数量级剧增的新兴科技。例如，电影和电视技术让比以往更多的观众能看到演员们的表演。</p><p>　　我们花了很长时间，经过大量的反复试验，才找到了解决成本问题的方法。这也就是当下新兴的数字社会：当我们将人类个体的健康和欲望等肉体和精神的信息转化为数据集，人类就可以成为数字世界的一部分，在那里我们可以被算法管理，为了实现“效率”，每个人都必须成为可以被其他数据位处理的数据位。</p><p>　　人工智能软件将为无限数量的客户提供治疗、咨询和娱乐，只要相关信息事先已经数字化。当我手腕上的手表分析我的生命体征时，算法可以为我的健康问题开发定制的解决方案。2013年的预言电影《她》描绘了一个拥有情感能力的人工智能，“她”有着女演员斯嘉丽·约翰逊（Scarlett Johansson）迷人的声音，同时和数百万人谈情说爱。这就是《数字化人类》（Homo digitalis）所发出的憧憬：一个从人体极限中解放出来的世界。</p><p>　　正如富雷斯蒂埃预测的那样，人类是服务社会的核心，但为了满足当今对增长的永不枯竭的渴望，人类必须首先实现数字化。新冠大流行清楚地表明，一旦人们摆脱了面对面接触的必要性，在线实现增长是完全可能的。</p><p>　　显然，最大的问题是，数字化治疗是否会比疾病本身更糟糕。机器人会取代人类并导致人类因此陷入贫困吗？工业流水线工作是否会通过脸书和网飞让位于思想的泰勒主义？让人类陷入一种思想上的“标准操作方法”？</p><p>　　通过历史时间的不断轮回，数字世界正在取代工业世界，而工业世界的老问题也正在数字世界中重新浮出水面。因此，我们是否必须重蹈旧世界的每一个阶段，包括道德破产、金融危机和经济不安全，还是我们可以做得更好？</p><p>　　到2022年，我们可能就会有答案了。</p><p>　　（作者系巴黎经济学院校长、董事会主席，最近著有《不光彩的年代》）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新冠肺炎疫情的暴发，让面对面的交流接触成为了一种负担甚至是一种可怕的行为。为了让人们远离感染的风险，并防止大面积的感染造成的卫生系统的不堪重负，在许多国家，餐馆、咖啡馆、音乐厅和其他对繁荣的城市文明必不可少的文化设施，被关闭了长达一年之久。生活退回到家庭中，足不出户成为常态</summary>
      
    
    
    
    <category term="精华转载" scheme="https://q.billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>江苏省信息技术合格性考试自制攻略</title>
    <link href="https://q.billma.top/2021/12/19/xinxitest-gl/"/>
    <id>https://q.billma.top/2021/12/19/xinxitest-gl/</id>
    <published>2021-12-19T04:46:39.000Z</published>
    <updated>2021-12-19T05:20:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-进制转换"><a href="#1-进制转换" class="headerlink" title="1.进制转换"></a>1.进制转换</h2><h3 id="标准算法"><a href="#标准算法" class="headerlink" title="标准算法"></a>标准算法</h3><p>十进制—&gt;二进制</p><p>对于整数部分，用被除数反复除以2，除第一次外，每次除以2均取前一次商的整数部分作被除数并依次记下每次的余数。另外，所得到的商的最后一位余数是所求二进制数的最高位。</p><p>对于小数部分，采用连续乘以基数2，并依次取出的整数部分，直至结果的小数部分为0为止。故该法称“乘基取整法”。</p><p>给你一个十进制，比如：6，如果将它转换成二进制数呢？</p><p>10进制数转换成二进制数，这是一个连续除以2的过程：</p><p>把要转换的数，除以2，得到商和余数，</p><p>将商继续除以2，直到商为0。最后将所有余数倒序排列，得到数就是转换结果。</p><p>听起来有些糊涂？结合例子来说明。比如要转换6为二进制数。</p><p>“把要转换的数，除以2，得到商和余数”。</p><p>那么：要转换的数是6， 6 ÷ 2，得到商是3，余数是0。<br>“将商继续除以2,直到商为0……”</p><p>现在商是3，还不是0，所以继续除以2。</p><p>那就： 3 ÷ 2, 得到商是1,余数是1。</p><p>“将商继续除以2，直到商为0……”</p><p>现在商是1，还不是0，所以继续除以2。</p><p>那就： 1 ÷ 2, 得到商是0，余数是1</p><p>“将商继续除以2，直到商为0……最后将所有余数倒序排列”</p><p>好极！现在商已经是0。</p><p>我们三次计算依次得到余数分别是：0、1、1，将所有余数倒序排列，那就是：110了！</p><p>6转换成二进制，结果是110。</p><p>二进制数转换为十进制数</p><p>二进制数第0位的权值是2的0次方，第1位的权值是2的1次方……</p><p>所以，设有一个二进制数：0110 0100，转换为10进制为：</p><p>下面是竖式：</p><p>0110 0100 换算成十进制</p><p>从右往左开始换算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第0位 0 * 2^0 = 0</span><br><span class="line">第1位 0 * 2^1 = 0</span><br><span class="line">第2位 1 * 2^2 = 4</span><br><span class="line">第3位 0 * 2^3 = 0</span><br><span class="line">第4位 0 * 2^4 = 0</span><br><span class="line">第5位 1 * 2^5 = 32</span><br><span class="line">第6位 1 * 2^6 = 64</span><br><span class="line">第7位 0 * 2^7 = 0</span><br></pre></td></tr></table></figure><p>得到01100100(2)&#x3D;4+32+64</p><h3 id="偷懒算法"><a href="#偷懒算法" class="headerlink" title="偷懒算法"></a>偷懒算法</h3><p>打开计算器（在开始里面直接搜计算器），打开后点击左上角的选项，在里面选择“程序员”，选择原始进制，输入数字，然后<strong>不要点等号</strong>，直接选择<strong>你要转换的进制</strong>即可。</p><h2 id="2-IP"><a href="#2-IP" class="headerlink" title="2.IP"></a>2.IP</h2><p>Pv4：本质上是四个八位二进制数，为了方便表达改为四个十进制数 ，以 . 隔开，每一个数字取 0-255−255，例如 12.34.56.78。</p><p>IPv6：八个十六进制数，以 : 隔开，主要是防止 IPv4 不够用。</p><h2 id="3-缩写大全"><a href="#3-缩写大全" class="headerlink" title="3.缩写大全"></a>3.缩写大全</h2><p>局域网：LAN（Local Area Network），小范围的网络，1km 以内传输效率极高，结构简单。</p><p>城域网：MAN（Metropolitan Area Network），数千米至数十千米内。</p><p>广域网：WAN（Wide Area Network），数十千米至数千千米以上。</p><p>随机存储器：RAM（Random Access Memory）。</p><p>只读存储器：ROM（Read Only Memory）。</p><p>万维网：WWW（World Wide Web）。</p><p>文件传输协议：FTP（File Transfer Protocol）。</p><p>简单邮件传输协议：SMTP（Simple Mail Transfer Protocol）。</p><p>对等网络：P2P（peer-t(w)o-peer），音译。</p><p>邮局协议第三版 ：POP3（Post Office Protocol - Version 3）。</p><p>传输控制协议：TCP（Transmission Control Protocol）。</p><p>用户数据报协议：UDP（User Datagram Protocol）。</p><p>交互邮件访问协议：IMAP（Internet Message Access Protocol）。</p><p>超文本传输协议：HTTP（S）（Hyper Text Transfer Prtcl（over Securesocket ayer）），带 “S”的为增加了传输加密和身份认证。</p><h2 id="4-录入程序"><a href="#4-录入程序" class="headerlink" title="4.录入程序"></a>4.录入程序</h2><p>有时候题目会给你一个程序，让你选出答案。这时候可以录入到Python中进行模拟，可是考试系统是全屏的，无法直接录入，怎么办呢？</p><h3 id="1-打开桌面上的Python-IDLE，打开后CTRL-N新建一个文件。"><a href="#1-打开桌面上的Python-IDLE，打开后CTRL-N新建一个文件。" class="headerlink" title="1.打开桌面上的Python IDLE，打开后CTRL+N新建一个文件。"></a>1.打开桌面上的Python IDLE，打开后CTRL+N新建一个文件。</h3><h3 id="2-打开考试系统"><a href="#2-打开考试系统" class="headerlink" title="2.打开考试系统"></a>2.打开考试系统</h3><p>注意这里：点开考试系统全屏后<strong>按住键盘上的Alt按键不要松开</strong>，轻点一下<strong>tab按键</strong>，会出现程序选择的界面。<strong>始终不要松开ALT</strong>，轻点tab进行选择，直到选择到Python界面，松开alt，你就会发现Python已经浮在了考试系统的上面，然后录入程序即可。</p><p><em><strong>注意：如果程序最后没有print函数，请自行添加，否则计算结果不会出来的</strong></em>。</p><h2 id="5-音频大小"><a href="#5-音频大小" class="headerlink" title="5.音频大小"></a>5.音频大小</h2><p>声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。</p><p>采样频率是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。</p><p>采样位数是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。</p><p>声道数是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。</p><p>不经过压缩，声音数据量的计算公式为：</p><p>数据量（byte）&#x3D;（采样频率（Hz）×采样位数（bit）×声道数）&#x2F;8</p><p>（其中，单声道的声道数为1，立体声的声道数为2）</p><p>例子：请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？</p><p>根据公式：数据量&#x3D;（采样频率×采样位数×声道数×时间）&#x2F;8 Byte(比特)</p><p>得，数据量（MB）&#x3D;[44.1 × 1000 × 16×2×(5×60)] &#x2F;(8×1024×1024)&#x3D;50.47MB</p><p>计算时要注意几个单位的换算细节：</p><p>时间单位换算：1分&#x3D;60秒</p><p>采样频率单位换算：1kHz&#x3D;1000Hz</p><p>数据量单位换算：1MB&#x3D;1024KB&#x3D;1024×1024Byte&#x3D;1048576Byte</p><h2 id="6-图片存贮"><a href="#6-图片存贮" class="headerlink" title="6.图片存贮"></a>6.图片存贮</h2><p>大小&#x3D;分辨率*位深&#x2F;8</p><p>分辨率&#x3D;宽 x 高（如：1024 x 768,640 x 480）</p><p>位深：如24位，16位，8位</p><p>&#x2F;8计算的是字节数。</p><p>例如：</p><p>一幅图像分辨率：1024*768,24位，则其大小计算如下：</p><p>大小&#x3D;1024*768824&#x2F;8&#x3D;2359296byte&#x3D;2304KB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-进制转换&quot;&gt;&lt;a href=&quot;#1-进制转换&quot; class=&quot;headerlink&quot; title=&quot;1.进制转换&quot;&gt;&lt;/a&gt;1.进制转换&lt;/h2&gt;&lt;h3 id=&quot;标准算法&quot;&gt;&lt;a href=&quot;#标准算法&quot; class=&quot;headerlink&quot; title=&quot;标</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>转载：《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信》及其批判信</title>
    <link href="https://q.billma.top/2021/12/04/1202ccf/"/>
    <id>https://q.billma.top/2021/12/04/1202ccf/</id>
    <published>2021-12-04T13:56:38.000Z</published>
    <updated>2022-01-09T02:16:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信"><a href="#关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信" class="headerlink" title="关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信"></a>关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信</h2><p>致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志:</p><p>首先，请允许我对昨日发生在贵学会的事表达诚挚的告慰和深切的哀思。</p><p>昨日，即公历公元二零二一年十二月三日星期五，农历辛丑年十月廿九日。在这个清列的冬日，在夕阳已没入北京地平线下的晚六时零五分七秒，一篇题为《关于个别选手在NOIP2021中使用暴戾语言的处罚公告》的公文赫然出现在贵学会所主办的全国青少年信息学奥林匹克竞赛的官网上。这篇文章实在可恶，作者其人对学会攻击之情、抹黑之义溢于言表。我见此文，不免义愤填膺，一日不为学会据理力争、正本清源，则寝食难安。</p><p>在文中，此人决定取消5名选手的NOIP2021成绩;禁止其参加NOI系列活动和认证一年;并对选手所在学校和指导教师通报批评。那么，这些学生到底违反了哪条纪律规定，以至于被取消成绩、禁赛一年呢?</p><p>此人一开篇便给出答案了∶这些学生在个人提交程序中使用对CCF的侮辱性网络暴戾语言’∶好吧，原来这些学生是惹了学会不高兴。可是，学会所主办的NOI及其附属NOIP毕竟是一项明确列入《教育部办公厅关于公布2021—2022学年面向中小学生的全国性竞赛活动的通知》的全国性竞赛。这项被教育部认可的竞赛的成绩,总还是和强基计划、I0l集训队保送这些升学机会有所联系的。在这项竞赛中取消选手成绩的能力，不得不说是一种公权力，而公权力向来是法无授权不可为的。想来发文者也懂得此法治道理（毕竟他是熟悉社会主义核心价值观的)，因此他总要找一项规定来安在学生们的头上。可是，他翻遍了故纸堆，不论是人大通过的法律、教育部制订的规章、主管部门的《中国科协全国五项学科竞赛条例》，还是计算机学会自己的《全国青少年信息学奥林匹克竞赛条例》《全国青少年信息学奥林匹克联赛组织指南》，竟然都没规定暴戾语言是一项足以危害竞赛公平、取消成绩的罪行呢!</p><p>此人不仅找不到罪行，反倒在《民法典》和司法解释中找到了关于名誉侵权的一般责任，竟然是责令教育、公开道歉、消除影响、赔偿损失。毕竟，中国计算机学会是个独立社团法人。这下，不是和取消成绩的目的毫无关系了吗?于是此人只好寻找那些捕风捉影的帽子了。别说，还真让他找到了一个!</p><p>这个帽子是什么呢?这就是国务院办公厅印发的《关于全面加强新时代语言文字工作的意见》。国务院的《意见》的第八条写道: .…加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。…”P瞧O瞧，只要我把程序代码定义为”互联网新媒体语言”把取消选手成绩和禁赛定义为“教育”这不就是”贯彻落实国务院意见”了么?至于”教育”到底能否包括在无具体规定的情况下取消成绩并禁赛”，《意见》二十一条中讲的“夯实语言文字工作法治基础”又有何含义，那些”暴戾”的参赛者怎么可能想得到呢!</p><p>此人想到这里，似乎终于松了一口气而觉得自己的处罚合理了，似乎终于觉得要求”批评教育道歉赔偿′”和”禁赛”只是处罚的轻重之别了，似乎终于说明学会的公权力可以躲在对国务院文件的随意打扮后头，绕开繁杂的规范为所欲为了。于是，他暂且放下了为取消成绩寻找依据的脚步，转到另一件事上来了。</p><p>另一件事是什么呢?那就是按照他写出的处罚理由”暴戾语言”，违犯的学生竟达到数百之多哩!在NOIP2021中仅仅程序代码同时含有’fuck和c两个英文词的选手，就至少有109(壹佰零玫)人。那么，为了“建设健康文明的网络语言环境的索高目的，把这些人全部取消成绩禁赛一年不就好了吗?当然不好了!毕竟要是毫无规定就禁赛数百名选手，必然导致竞赛的大反对，那怎么达到安稳”教育的目的呢!可是，又如何能让自己在数百选手中只看到五个人的暴戾”呢?当然是因为只有他们五个人被”实名举报”了!这样，要是有人问如何举报’，只要搬出对举报人保密的义务;要是有人问责成相关省组织单位进行情况调查为何漏掉了其余数十上百的选手，只要怪省组织单位调查不力，责成重新调查;要是有人问为何不受理其它举报，只要说公示期已经结束不就好了嘛!谁让你们愚蠢，不看到处罚公告就想不到还可以通过举报暴戾语言来取消别人成绩呢?</p><p>既然把这两件事——即为何能无视规定条例随意处罚学生，和处罚学生为何在数百人中独爱五人–论述清楚，此人的公文也该作结了，只要最后署名中国计算机学会，就能把以上两个责任和歪理都推在独立社团法人、中国计算机学会的头上啦。只要于星期五傍晚六时发送公告，使学会于周末休息日难以应对，过了两天，事情自然生米煮成熟饭了!</p><p>到挪时，被处罚的学校，痛感不公的同志诸君，将只会批判中国计算机学会滥用主办方权力，将未违反法律法规及竞赛条例的选手取消成绩并禁赛了。到那时，他们就还会搬出《中国科协全国五项学科竞赛条例》的第二十七、二十八条，声讨学会事实上擅自更改参赛学生的竞赛成绩，科协应当主管监督了。到那时，他们就怀疑这种无规定依据的选择性判罚给了利益输送、权力寻租以空间，或至少给了私相授受、恶意举报以机会了。<br>到那时，他们就会在最低限度上，至少要求CCF撤回一切以程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告承认错误、说明情况，以维护学科竞赛之教育公平和公信，并作坚决的斗争了!<br>可是这一切，都和处罚公文的作者没有关系了。</p><p>如此一篇欲陷学会于不义的公文，竟然堂而皇之地出现在学会主力的竞赛网站首页，不能不让关心学会、热爱计算机教育者痛心。但好在事情尚可收拾，只要立刻撤回一切以程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告说明情况，以维护竞赛之教育公平和公信，广大师生自然会和公义、和法治站在一起,完善教育规范，消除暴戾风气，支持学会加强学科竞赛的精神文明建设。毕竟，当前师生还要借助学会主办的竞赛来参与和发展算法、计算机基础教育。朴素的公正愿望，满足这些也就可以缓和了!</p><p>此致</p><p>附则1:中国计算机学会主办全国青少年信息学奥林匹克竞赛网站上的处罚公告原文: https:&#x2F;<a href="http://www.noi.cn/xw/2021-12-03/750909.shtml33">www.noi.cn/xw/2021-12-03/750909.shtml33</a></p><h2 id="附录：关于个别选手在NOIP-2021中使用暴戾语言的处罚公告"><a href="#附录：关于个别选手在NOIP-2021中使用暴戾语言的处罚公告" class="headerlink" title="附录：关于个别选手在NOIP 2021中使用暴戾语言的处罚公告"></a>附录：关于个别选手在NOIP 2021中使用暴戾语言的处罚公告</h2><p>NOIP 2021于11月20日在全国31个赛区同时举行。竞赛整体进展平稳顺利，但也发现了极个别严重违反社会主义精神文明建设的行为。CCF现将情况和处罚公告如下。</p><p>在NOIP申诉期内，我学会接到多封实名举报，指出个别选手提交的NOIP 2021个人程序中存在对CCF的侮辱性语言。经我学会NOI评测组核实，举报情况属实。我学会责成相关省组织单位进行情况调查。根据调查结果，相关选手确实在个人提交程序中输入了侮辱性等网络暴戾语言。</p><p>根据NOIP规则，各省在赛后第一时间公示选手程序，是为了加强选手间的交流和学习，但是这些带有网络暴戾性质语言的程序，也在一定范围内广泛传播，严重破坏了NOI选手的整体形象和道德声誉，也给CCF造成了极为负面的社会影响。</p><p>国务院办公厅近日印发的《关于全面加强新时代语言文字工作的意见》指出，要“加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。”</p><p>为维护NOI竞赛秩序，遏制影响中学生身心健康发展的不良行为，CCF决定，取消GD-0081赖* 旭（华南师范大学中山附属中学）、GD-0785张* 铭（中山市中山纪念中学）、HA-0101王* 康（郑州市第十一中学）、SC-0027毛* 祥（成都外国语学校）、ZJ-0071姜*丞（浙江省衢州第二中学）的 NOIP 2021成绩；即日起，禁止其参加NOI系列活动和认证一年；并对选手所在学校和指导教师通报批评。</p><p>CCF认为，在NOI系列竞赛和认证中，选手的道德培养是非常重要的部分。所有选手及其指导教师都应当在培养选手竞赛知识和能力的同时，加强选手的道德文明教育，使选手真正成为社会主义建设的有用之才。</p><p>此公告。</p><p>中国计算机学会</p><p>2021年12月3日</p><h2 id="扩展阅读：批判《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会等的公开信》——全面、现实、严肃、深入地分析和解决问题"><a href="#扩展阅读：批判《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会等的公开信》——全面、现实、严肃、深入地分析和解决问题" class="headerlink" title="扩展阅读：批判《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会等的公开信》——全面、现实、严肃、深入地分析和解决问题"></a>扩展阅读：批判《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会等的公开信》——全面、现实、严肃、深入地分析和解决问题</h2><blockquote><p>理论一经掌握群众，也会变成物质力量。理论只要说服人，就能掌握群众，而理论只要彻底，就能说服人。所谓彻底，就是抓住事物的根本，而人的根本就是人本身。——卡尔•马克思 《&lt;黑格尔法哲学批判&gt;导言》</p></blockquote><h3 id="一、《公开信》的目的和片面性"><a href="#一、《公开信》的目的和片面性" class="headerlink" title="一、《公开信》的目的和片面性"></a>一、《公开信》的目的和片面性</h3><p>我想，各位同学都读过《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信》了。</p><p>这封信的每一个字，每一句话，每一个段落和论证都是正确的。可是，它有一个最为错误的地方。</p><p>那就是，它不够严肃。</p><p>或者说，这封信是一个手段，它是为了一个目的而写的。</p><p>这个目的是什么呢？那就是，要求撤回对5名选手的取消成绩和禁赛处罚。</p><p>正是为了这个目的，它的标题把事件称作“无规定选择性取消NOIP选手成绩事件”，而不是事实的“CCF《关于个别选手在NOIP 2021中使用暴戾语言的处罚公告》事件”。</p><p>正是为了这个目的，它是一个宣传材料。一篇鼓动选手用两个论点向CCF进攻的宣传材料。</p><p>那么，这个目的足够崇高吗？经过反思了吗？</p><p>我很想说，它是足够崇高的。但是，并不是这样。这个目的——要撤销对选手处罚的目的，是在得知这个消息的第一时刻，从下意识中产生出来的。这个目的是未经反思的，不崇高的，不能说服人的。这个目的为了实现自身，不得不把自身包装成另外的东西。那个东西就是竞赛的良性发展所需的公平正义和法治。</p><p>一个被包装出来的事物，由于它要按原本目的对包装作裁剪，总是片面的。片面就在于，它无法站在现实的也即普遍的“竞赛良性发展”角度来考虑问题，而走向了法治之分析法条的片面性；它无法完整把握整件事中密切联系着的选手行为和处罚决定两个方面和它们的关系，而走向了只找处罚问题的片面性；它无法站在全部主体即学会成员和学生、家长、学校、作者本人等各方面考虑问题，而走向了忽视学会成员主体性并赋予它们任意假设的片面性。</p><p>这三个片面性，注定了《公开信》与它的读者是冲突的，甚至是南辕北辙的。它的内容对于读者特别不彻底，因而不能通过说服人达到它所用于包装自己的公平正义和法治的现实结果，因而也不可能达到它本身要求的取消判罚的结果。</p><p>在这里，我们将把这三个片面性所遮蔽之物全部展开，把理论讲得更彻底，届时一条真正维护竞赛的良性发展所需的公平正义和法治的道路会自然展现在我们面前。</p><h3 id="二、现实普遍的竞赛良性发展"><a href="#二、现实普遍的竞赛良性发展" class="headerlink" title="二、现实普遍的竞赛良性发展"></a>二、现实普遍的竞赛良性发展</h3><p>《公开信》的大致内容，是由两点不合规的事实推出整个处罚的不合规；《公告》的大致内容，则是援引指导性文件对选手进行批判。这两者的共同点，在于从规章、法条、文件这些被赋予了法的权威性的话语中寻找达成事实的条目。否则的话，后者就无需引用内容模糊的文件了。</p><p>法治的形式，在于严格的依规依法办事。严格要求法的形式是法律运行和明确约束权力等功能的基础。在当前历史条件下，我国推进依法治国，学会也在推进依法治赛。因此，我当然主张，为了法治权威的大局，应当严格执行规定，采用有据可依的要求道歉和纪律处分等方式解决问题。我们知道，国家法律是社会的统治阶级依照形成它自身的规律，通过它们内部妥协产生的规则和共识，以国家机关这一表示集体意志的形式，依靠国家强制力（暴力机器）和社会权力关系的保障和严格执行的权威来运行的一种强制调节社会矛盾的框架。从法律中延伸出来的各级规则体系，自然也是依照某种集体组织的强制力来规范行为、调节矛盾的。从这个角度看，法治形式本身的局限性就很清楚了。那就是，法治是调节控制矛盾的工具，却不是解决矛盾的方法。例如，本次事件中，有取消判罚诉求的和学会决定矛盾的选手就从规章中寻找自己行事的依据。这当然是法治精神。但是，仅仅是诉诸法治，即诉诸调节矛盾的形式，而因此不考虑解决矛盾的办法，就不可能有进步而只能试图保持既有体系的不崩塌。用法律遮蔽问题，用压制矛盾取消解决矛盾的探索，这是资本主义的法权凌驾于现实的抽象的法治，不是追求解放人发展人的社会主义的法治。 一边用法律维系体系中人的基本生存，一边分析实践探索矛盾的解决之道，才是社会主义的法治精神。</p><p>因此，当然地，在这个问题上争论CCF的解释力有多强，“扰乱竞赛秩序”的范围有多大，这些法条问题固然对法律的权威是重要的，但是它们却远远不能遮蔽对矛盾本身的探索。即对选手辱骂CCF这一现象背后各类深浅原因的追问和解决。我对这个追问和解决的详细见解，将在下文中展开。</p><h3 id="三、选手错误和惩罚的关系"><a href="#三、选手错误和惩罚的关系" class="headerlink" title="三、选手错误和惩罚的关系"></a>三、选手错误和惩罚的关系</h3><p>毫无疑问，这个惩罚是针对选手辱骂学会的反应，这一点将在下节得到验证。那些“这次xxx，下次yyy”的无前提的随意类比，都是建立在“辱骂学会本身并非惩罚的原因，而只是一个借口。”的猜想上。但实际情况并非如此，这一点也将在下节得到验证。当然，这样的猜想，是因为学会的处罚公告也和公开信一样，不得不用一般的社会主义精神文明建设和国务院办法来包装自己，因而也产生了片面性。被误解是不奇怪的。</p><p>既然辱骂学会就是处罚的原因，那么要解决问题，就必须也搞清楚辱骂学会这一现象的原因。</p><p>请想想吧，你现在是否因为这一事件更加气愤，更想辱骂学会了呢？</p><p>许多人的答案是肯定的。那么，请再想想，你是否像本文那样，考虑过你的思维的片面性？</p><p>你是否不加批判地接受网友说的，我们是在维护法治因而我们是完全正义的？</p><p>你是否不加批判地接受网友说的，学会只是找借口，因而选手的行为和学会的做法无关，不需要深入研究如何解决选手的问题？甚至武断地宣判它无解？</p><p>你是否不加批判地接受网友说的，学会就该机械般无条件严格按规则行动，收费或者出错就是倒行逆施？你是否把自己所听说的，抽象的“社会的黑暗”——如金钱至上、官官相护、私相授受、权力寻租，不加考察地代入了学会？你是否尝试考虑过学会成员的想法？</p><p>如果答案为真，那很遗憾。因为你即使是在和自己切身相关的信息学竞赛问题上，也缺乏辩证和批判思维。当然，你是未成年人，在心理发育过程中这是难免的；又，有缺乏信息渠道等种种现实困难阻止你的进一步思考。但无论如何，这样的你对CCF的态度不是你自己的，而是从网友那里记忆来的，是一种网络模因，它在你不思考地吃瓜看乐子时日积月累地改变你的下意识，让你盲目从众，并使你在叛离时，在代码调不出想要宣泄情绪时将矛头对准你下意识中的那个强权——CCF。</p><p>所看的言论是哪里来的呢？本来，那些言论所依附的事实都是明确而重要的——CCF收费、比赛故障、题目质量差、取消省队名额等等……在记忆中，每次也有确实分析提出建议的讨论。可是，我们怎么还在这里接受模因，看乐子呢？</p><p>第一个原因，是我们不知道如何严肃面对竞赛问题；或者没有来自竞赛方面现实具体的生活压力。因而就不能从解决问题的角度严肃反思竞赛问题，反而不得不从暴戾语言那里享受一种虚假的反思和批判感。</p><p>前者，即无法严肃面对竞赛问题，首先是由无法与教练群体、命题人、CCF、科协、教育部联系的无力感造成的；其次是由与他人或理想自我等反差导致的自卑感或无力感造成的；第三，是由于从各种渠道接受的对社会不公、体制问题等的抽象批判带来的焦虑，对现状和前途的完全迷茫导致的绝望和虚无；第四，就是特殊经历造成的心理创伤。解决这些问题，主要从建立CCF和选手有效联系和心理建设（关于更具体方法，另文详叙）角度考虑，解决更深层动因则需从社会主义原则考虑。</p><p>后者，即我们能够不严肃对待竞赛的生活体验基础，就是信息竞赛体制本身所创设的临时的自由。在信息竞赛学习时，学生首先脱离了之前应试班集体的律令体系和集体关系，在学习中缺乏竞赛知识以外的交流，学习过程自治（因为信息竞赛教师往往不直接传授困难知识，需要大量自学），又在信息竞赛社区中受互联网的自由思想影响，很容易形成个人主义倾向。在个人主义倾向下，在社会上计算机行业的热潮下，许多学生容易认为自身在现在或者将来有自我生存的能力（因为当前临时的自学状态和对未来生活方式的小资产阶级理想），缺乏集体观念，缺乏现实人际交流，容易对互联网社区和互联网片段化信息产生认同。而OI社区就是一个互联网社区。如果没有引导，产生把互联网和现实对立起来，把OI社群和CCF或其它方面对立起来，二元对立，认为其中一种的极端化为理想，认同一个而厌恶另一个的思想也不奇怪。这样，就会产生一种完全抽象的批判的姿态，甚至在遇到挫折等后不与人交流以至于走向虚无或走极端。</p><p>信息学竞赛提供自由的本意，在于充分发扬学生学习的主体性。要解决这个问题，也即激发学生的主体性。这方面，luogu的月赛日报社区管理，各种OJ、命题和开发社区，各种有具体内容的学术群和文化课群，是第一类经验，即在OI社群内部引导良性内容的经验。教师对教学的详细管理，对具体教学活动的参与，和学生的交流，是第二类经验。家庭教育是第三类经验。另外，有些问题迄今无良好方法，如文化课班级和竞赛的调和（很难既保持集体生活又避免心理压力导致竞赛和文化课的二元对立），以及如何在OI中建立集体体验。</p><p>以上两者，是许多学生能够潜移默化接受跟风，辱骂CCF的主要原因。除此之外，对CCF的情绪化宣泄也有其它来源，这构成风气的起点。</p><p>第一，部分家长、教练等因为收费、比赛故障、政策内容或政策变动等原因，由于利益受损，对CCF进行攻击。这种攻击有其原因，其存在是可以理解的，由于利益关系的复杂性和成年人思维方式的稳定，在计算机基础教育的内部恐怕无法解决，只能通过改革一定程度缓解以及引导无意义的情绪宣泄为有根据的批评。</p><p>第二，部分退役学生（主要是大学生）因为仍然留在OI信息传播社群中，但又脱离了OI的切身利益。因此，他们由于没有深入了解或思考现状，或者个人性格等原因，在之前OI时期的下意识影响下，继续大量传播情绪化信息。由于这些信息直接流入学生互联网社群，也会造成重大影响。</p><h3 id="四、学会成员的主体性"><a href="#四、学会成员的主体性" class="headerlink" title="四、学会成员的主体性"></a>四、学会成员的主体性</h3><p>成年人是怎样的人？</p><p>当然，我们有许多刻板印象。成熟冷静，思想复杂，社会经验丰富，工于心计，注重利益……这些标签，每个都可以贴在某时某刻的某些人身上。</p><p>但首先，成年人是人。人有主体性，它本身就不能被符号所完整把握。成年人不是近似于所有刻板印象的总和。更不是我所想象的理想自我的反面。</p><p>来看一段话吧：</p><blockquote><p>“如果是“赛”，就不让收费……不让收费呢，CCF是没钱的。……500名同学呢 ，你就要失去机会。……今年呢，就是⼀个多事之春，从冬令营开始到现在还没有完全停⽌……总有⼀种⼒量想把我们从正道上拨到邪路上去。……（⼀种态度是）坚信CCF是为⼤家考虑的，是为我们青少年考虑的……我们的宗旨是给那些学有余⼒的学⽣，有兴趣的学⽣，早⼀点接触计算机科学……也确实培养出了⼀批又⼀批的杰出的青年才俊。……（另⼀种态度是）遇到困难的时候顶不住，埋怨CCF。……我想没有第⼆个⼈像我这么热爱NOI，这么投⼊和为NOI着想。我不会把NOI断送掉，可是你们知道CCF的苦楚吗，你们知道我的苦楚吗？……后来我们是列在名单⾥头了，细节我不想跟你讲……有些事我也不便跟你们讲。……如果我实在达不到⽬的……我只能辞职⽽去，但绝不就范，绝对不……失掉真理，失掉正义和⾻⽓。”（《整形溢出》，第113-114页。这是一本出自OI学生之手的纪实文学，笔者引用它来说明部分学生心理。）</p></blockquote><p>想必参加过全国现场赛的同学们，都能感觉到这段讲话出自谁。参加过CTS2019的同学，可能还对此记忆犹新。当然，它出自NOI竞赛委员会主席杜子德。</p><p>初听这段话，似乎口气很大，“我想没有第⼆个⼈像我这么热爱NOI，这么投⼊和为NOI着想。”又显得有些矫情，把辞职说成是“绝不就范，绝对不……失掉真理，失掉正义和⾻⽓。”还有些造作，“总有⼀种⼒量想把我们从正道上拨到邪路上去。”而且也有大言不惭之嫌，“坚信CCF是为⼤家考虑的，是为我们青少年考虑的……我们的宗旨是给那些学有余⼒的学⽣，有兴趣的学⽣，早⼀点接触计算机科学……也确实培养出了⼀批又⼀批的杰出的青年才俊。”个别对CCF的收费或者组织失误不满的同学，听到这样的话当然怨气更大，都当做形式主义假大空。有些习惯了骂CCF的同学，看到这位占用他们时间的有权力的老先生，也是付之一笑。有困难的同学和更多离开生活的同学，听到“苦楚”更是暗自腹诽。更有许多人把他的历史名言——例如“做干净的竞赛”之类拿来揶揄。</p><p>当然，这是一位脾气倔强的老人，许多饱受争议的决定都是出自他手。例如被揶揄为“连坐”的扣省队名额处分——不过现在取消了。让我们来看看，这个省队处分是怎么一回事吧。</p><p>这种“省组织出问题，选⼿承担后果”的处罚形式对CCF⽽⾔早已驾轻就熟。从2015年开始，每年都会有不同的省份由于代码提交不及时或出错，选⼿作弊，题⽬泄漏等原因被CCF加以扣减省队名额或提⾼NOIP分数线这类惩罚。……按照⼀位选⼿的⽐喻，这种惩罚⽅式就好⽐“某省⾼考收 卷出现失误造成批阅延迟，于是该省⼀本线提⾼五分”以及“某省某校考⽣作弊，该省扣除五千个⼀本名额”的⾏径。没有哪个信竞⽣对这种惩戒⽅式持正⾯看法，尤其因为这些选⼿很可能由于省队名额的缩减⽽⽆缘NOI。但即使这类“连坐”式的惩罚⼿段⼀向是被⼜口诛笔伐的对象，CCF也丝毫没有表现出要改进它的意思。有⼈将其描述为“⽆耻的⾏径重复多次，话题度就⼤⼤的降低，以后就会被认为是正常操作。……问题的核⼼始终在于⼀点：通过惩戒选⼿来间接对省组织施加压⼒的⽅式真的有⽤吗？如果有⽤，效果究竟多好？ ……我们不得不⾯对的⼀个事实是，⾃2015年起，在NOIP中出现违规现象的省份数量⼏乎每年都在增加，⽽同⼀个省份连续两年乃⾄三年出现问题的情况也并不罕见。单从结果来看的话，这些惩戒措施即使不说是毫⽆⽤处，也可以被视作收效甚微。这就意味着我们得从另⼀个⾓度来分析这个问题。由于信息学竞赛近年来的热度不断攀升，NOI系列赛事的参赛⼈数每⼀年都在增加。赛事规模越⼤，对组织⽅的要求也就越⾼；但部分省组织单位的能⼒显然暂时不⾜以应付越来越⾼的要求，所以在举办过程中出现种种状况的概率是相当不⼩的。另⼀⽅⾯，CCF并⾮⾏政单位，对省组织单位的管控能⼒相当有限。（事实上，省组织单位都是独⽴的法⼈代表机构。）在省赛区竞赛委员会的诸多职位中，CCF唯⼀有权⼒任免的职位仅限于特派员；⾄于省组织单位的整改，CCF则⼏乎没有任何插⼿的余地。因此，CCF能够采取的有效惩戒⽅式相当之少，除去“对特派员及省组织单位通报批评”之外，唯⼀能体现惩罚效果及决⼼的就只有对这个省的“切⾝利益”，也即省队名额和NOIP⼀等奖名额作扣减了。（⾄于这是选⼿们的切⾝利益还是省组织单位的切⾝利益，则另当别论。）这在很⼤程度上折射出了CCF对此的⽆能为⼒。 由于“连坐”式的惩罚⽅式，俞同学（引用者注：因为博客时间问题引起恐慌被禁赛一年的同学）⼴受争议的遭遇，正式⽐赛中出现的问题，以及其他种种因素，CCF在选⼿中的声誉于2018年底跌到了⼀个最低点。（《整形溢出》，第95-96页。）</p><p>在2019年，仍然有这么一段评价：</p><p>CCF采取的处罚⽅案也毫⽆新意可⾔：迟交数据的省组织单位及特派员被批评并罚款；作弊者被禁赛三年，所在的省份被扣减1个省队名额；江西省被扣减2个省队名额，并被责成进⼀步追究有关⼈员的法律责任。如果说这就是所谓新时代的开端的话，那它和过去⽐起来充其量就是换了层⽪⽽已。CCF及其下属省组织单位的能⼒仍旧令⼈不敢恭维，选⼿们的被动地位也没有任何改变。或许唯⼀的不同之处在于他们已经习惯了这种状况的⼀再发⽣。 （《整形溢出》，第128页。）</p><p>诚然，CCF即使不能解决省组织的问题，作出一个对无辜学生不利的处罚也很不合理。因此，学生将作出这一决定的沉默的学会当作反面，就是不足为奇的了。一旦将其认定为反面，那么学会的一切行动都像是虚伪的。杜子德主席说“办干净的奥赛”，好像是沽名钓誉；学会处罚省组织，好像是推卸责任；学会取消连坐，好像是“广大学生的英勇斗争取得了胜利”，又好像是“和某些教练达成了不为人知的交易”；学会取消IOI环境，好像也是把CTSC2018的问题扣在改革和进步者的头上；学会编写大纲，好像是“伙同部分教练固化知识”，又好像是“搞应试教育化”；学会统一省选，好像是“急功近利，制造故障”；学会的三分之一限制，好像是“变相操纵省队”；学会的收费，好像是“吸血NOI学生补贴学会”，甚至“中饱私囊”。这些观点，有些不无道理，有些是捕风捉影，然而它们在许多学生眼中却都是来自于学会负面形象的结论。既然学会是负面形象，那么考虑学会的想法是一个禁忌，对学会非恶意的揣测，对真实意图的考察是不被思想允许的。学会的主体性，完全被它所扮演的负面形象遮蔽了。</p><p>这种遮蔽的社会基础，首先在于学会和学生、家长之间信息和权力的不对称，学会和学校等方面之间的利益冲突。在当下的社会中，权力的不对称，信息的不对称，交流的缺乏，容易让人在他们下意识的范围内以最坏的恶意揣测其它主体。 对学生来说，学会是支配他们学习的一方。并且，由于青少年时期心理结构的不完善，容易简单化投射一个主观想象的本质，或者说，容易用主观理解的善恶等简单符号来认识他人。在信息不对称，在学会不主动宣传和接触选手，在接受了社群内刻板印象的宣传，在由于缺乏经验、畏惧权力等原因不愿意、不敢了解学会的情况下，学生很容易用负面形象来短路对学会的认识，这可以说是某种面对权力无能为力时的“自我保护”。这是社会普遍存在的问题，但通过严肃的交流是可以缓解的。</p><p>可是，现在学生中这种负面形象完全遮蔽了真实的学会。我在这里问三个问题：</p><p>取消连坐，更新语言，编写大纲，开发NOI Linux 2.0，统一省选环境……这些作为是如何进行的？工作推进中产生的问题，是否已有更好的解决方案而被CCF视而不见？换言之，对学会收钱不作为的批评在哪些程度上是具体的？</p><p>有无任何证据，证明CCF NOI科学委员会的成员有不正当或者正当化的不良经济关系？换言之，做干净的奥赛在哪些程度上是具体的？</p><p>总而言之，学会是否在NOI工作上具有大的保守性、拒绝意见、私心或者主观恶性等问题？用对待敌人的态度攻击学会是否总体上利于竞赛和教育的良性发展？</p><p>第一个问题中提到的现象，无疑是学会NOI竞赛委员会领导教师、学生等共同完成的。</p><p>如NOILinux，由赵启阳老师及其研究生等共同维护开发。对他们的批评是很多的，如系统内的漏洞和缺陷，如接受建议动作太慢、技术水平不足，如怀疑垄断NOI Linux课题、剥削研究生……但是，这些批评要怎样解决呢？当然，我们可以提出各种各样的解决方案，如增加技术能力更高的人手及时处理缺陷迅速更新系统，如吸收部分技术能力强且主动性强的现役、退役学生参与系统测试和维护并给予应当报酬，以至于以此改革机构……问题在于，对NOI科学委员会来说这些建议是否特别困难？我本人参与赵启阳老师和学生的许多联系工作，包括收集NOILinux 2.0建议等。NOILinux要找到高技术的，同时能够快速迭代和保证安全的开发团队，因为缺乏资金和业务的单一等原因，是困难的；在选手内部，其实技术开发能力也极为不足。大部分的项目都是个人项目，缺少协作和维护经验；小部分质量较高的项目，其有相当技术水平的人员分布也相当分散，且均有利益相关疑虑和学业等掣肘，要用学生团队等代替赵启阳老师大学课题团队，当前不够现实。清华算协、王逸松同学等的项目技术水平，调研能力和创新能力较好，但他们也是另起炉灶，和NOILinux平行开发，待功能成熟后再行借鉴、迭代，似乎比直接替代更适宜。至于省竞赛环境统一遇到的技术和非技术困难，也非调查研究不能解决。目前要发挥学生的主体性，一个是可以建设开源平台让学生的临时、局部想法能够记录，二是需要建立稳定广泛的宣传联系渠道，三是主动到各地产生实际问题的地方进行调研。这些也是我本人和一批同学近期和长期的重大工作。</p><p>学会编写大纲、大纲辞典等整理竞赛知识体系，也是解决知识碎片化、不规范等长期问题的一个方案。但是，这项工作在和各校已有的教学体系，和大学、业界的要求和想法，和潜在出题人和毕业学生评判题目的标准，和知识的主力军现役学生的想法之间，会产生各种龃龉。这项工作中被批评的可能问题——如细化、僵化、固化、记背化知识体系，大纲在学界和题目张力之间的范畴，大纲指导命题的具体做法，如何保证OI自治的知识生产&#x2F;再生产不因此中断或者内卷化……这每一项问题都需对数学、算法、计算机科学的深入学习，对教学论的细致研究，对社会的科学的细致调研。还需要不断联系学会，联系各个实际参与编写的学生和教师。学会要在各方的差异中协调组织编写、审阅等一系列工作。这些也是我本人和一批同学参与的一项重大工作。</p><p>在协调竞赛师生、承办方、省组织、政策、高校、业界、部委等各方面，推进竞赛改革的工作上，杜子德主席本人更做了大量突出的工作。他在CTS2019上的讲话，和之前许多看似歌功颂德的讲话（特别著名的比如“做干净的竞赛”），是真情流露。我曾参与一些史料收集工作，也了解到稍许过去的情况（不便透露细节），我个人是信任杜子德主席的，只是我之前也由于自己未能和他交流，对他的巨大影响力的畏惧等原因，不愿意去体会他的感情。我调查过杜子德主席的公开经济信息，也在工作中接触到一些熟悉历史的成员，我没有看到任何谋私利的迹象。当然，如果你把学会当作他的私心，那么在2014-2018年大量增加的竞赛收入事实上的确被运用在了学会的其它方面，在2018年左右每年达到上千万元。不过，在强基改革之后，CCF已经不再把竞赛作为主要盈余来源，转而用发展计算机相关产业等其它手段解决问题。例如说，各个“西西艾弗信息科技有限公司”都是在CCF秘书长交接的2021年成立的。这方面倒也可以深入研究，不过就不要写在一篇面向OIer的文章里了。当然，CCF应该向当事人公开某些被质疑收费不合理活动，例如在线竞赛、教师培训等的支出情况，并改革如疫情取消活动等状况下的的退款工作。</p><p>我曾经见到许多选手抱怨某些省区竞赛活动舞弊嫌疑、乱收费、题目质量一言难尽等乱象。但是，当然地，推进统一各省竞赛环境是解决这些问题的主要方式，在这方面，CCF是必须起主要作用的。至于对CCF国级赛事的怀疑，以我个人参与相关活动的经验，除了“某些出题人可能平时太有名讲课太多，或者不遵守保密协议提前让人猜出出题人，导致有可能按人研究出题风格”，“严重疏忽和技术事故导致的出原题、原题重赛”这些问题外，其它明显影响竞赛公平的问题并未见过，这更加不是学会故意造成的。当然，偏题怪题原题等问题，以及比赛过程中的技术问题也是必须通过建立良好的命题管理、技术体系解决的。这其中具体的技术细节，仍然是我们需要参与的工作。</p><p>学会NOI竞赛委员会和科学委员会的成员，吴文虎、尹宝林、杜子德、陈文光、王宏、赵启阳、蒋婷婷、韩文弢等每位老师，都是活生生的人，有自己的思想，都在信息学竞赛中做了多年工作。他们对教育的热爱，不谋私利的作风值得我们所有人学习。当然，老师们带有许多个人或者时代的特点，或者由于精力有限、需要保密、沟通不充分等，经常表现得固执、权威、忽视学生等等。作为信息学竞赛教育方面的同志，我们应该对具体的错误展开彻底的批评和自我批评；但是，批评和善恶评判完全是两样东西。完整了解现状和自己的能力后选择不同的工作方式，和喊口号批判现状空想一个没有内容的乌托邦更加是不同的东西。</p><p>我们可以看到，学会的每项具体工作都有大量的具体问题，受到大量确实具体的批评。但是，学会并不是不关心结果，不能接受批评和改进工作，更不是不作为；主要受到的是历史惯性、交流缺乏和各种现实客观条件限制。这些并不能否认学会的贡献。更不能否认学会努力改善OI的作用和态度。</p><p>总之，学会在NOI方面做了深入复杂的工作，我本人也是许多工作的参与者，深知工作遇到的现实困难，是不能想着打倒学会建立一个没有蓝图的新世界而解决的。既然学会支持我们的实践，既然学会不反对改革，既然学会NOI委员会的领导都是为OI多年无私奉献的讲道理的工作者，我们就没有理由把学会看作对立面，凭着想象和不完整的印象拒绝现实的实践的条件。我们只有在现存的体制中不断实践，在旧办法中创造和验证新办法，因为整体性解决问题的方法只能从具体每项工作的实践中，而不是几个理论家坐在书桌前对着思辨、概念和统计数据的空想中产生。 而要发扬学生的主体性，使建议和个别的经验能够推广，学会和学生的经常交流和通力合作是非常必要的。保护和发扬学生和教师的主体性，鼓励学生主动实践，组织学生，改善OI各方（特别是学生、弱校教师之间和他们与学会之间）的交流条件，是我本人在一个若干年的长时间内做OI工作的总任务。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>因此，我们不要说：</p><blockquote><p>只要立刻撤回一切以“程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告说明情况，以维护竞赛之教育公平和公信，广大师生自然会和公义、和法治站在一起，完善教育规范，消除暴戾风气，支持学会加强学科竞赛的精神文明建设。</p></blockquote><p>那是谈条件，是针对敌人的口气，是针对守护腐朽制度的死硬的保守派既得利益者的口气。不是针对计算机基础教育建设者，我们最亲密同志的口气。更加不是针对一个无私者的口气。</p><p>我们要说：</p><blockquote><p>为了信息学竞赛选手的道德教育和精神文明建设，为了选手的主动性和有益建议的及时传达，需要加强CCF和选手的联系，经常地和选手说明历史和现实，说明规则和想法，消除CCF和选手之间由于不交流造成的虚假对立形象。在这一基础上，严格执行规定以贯彻当前提出的依法治赛理念是有必要的。因此，需要考虑选手对自身错误的认识情况，重新考虑目前对禁赛、取消成绩等规定外惩罚措施的使用，后续完善规则对暴戾语言一致处理；并向选手充分宣传CCF做出决定的原因和依据，以及CCF的现实贡献。</p></blockquote><p>也许你会问，这不还是要取消竞赛方面的处罚吗？有什么区别？</p><p>我的回答是：这是真正从竞赛良性发展出发，在更全面的角度分析得到的做法。正因为抱着真正经过反思的崇高的目的，才更能解释和解决下意识产生的冲动的目的。因为崇高的目的之所以崇高，就是因为它和下意识相容。</p><p>也许你会问，这不是因为杜主席的个人想法而做的变通吗？这不是因为杜主席的一言堂造成的吗？这是否可以通过学会内部的民主，而不需要修改措辞来解决呢？</p><p>我的回答是：不行。</p><p>因为，之前的处罚决定其本身，就是一个民主决定。因为各个在学会为计算机教育事业奉献了多年的人，都很难接受一个被破口大骂的现实，很难接受一个仅靠条文的辩护。这里，不能认为缺乏规则条文所以无法处罚的法条道理必然是至高无上的。</p><p>这是一个悲剧，一个来自于误解的悲剧。悲剧的种子早在CCF和选手社区间不存在联系的那一刻就埋下了。</p><p>只有站在人的角度把理论讲彻底，抓住解决问题的根本——而不是把法条提高到比主体性更高的位置来指责——才能够消除这样的悲剧。</p><p>我们不仅要做干净的奥赛，而且要研究如何做干净的奥赛，懂得如何做干净的奥赛，在未来不断做更干净的奥赛。</p><p>而不是，讽刺着奥赛不够干净，然后想象该负责任的是谁。</p><p>最后，让我们用《整形溢出》的一段话做结。</p><p>是谁被调剂到和竞赛学科毫⽆关联的专业？是选⼿。是谁被弄丢代码，因为莫须有的原因被禁赛，由于同省考⽣的违规⾏为⽽错失省队名额？是选⼿。是谁被不明就⾥的⽹友斥责为所谓“权贵”？是选⼿。是谁整天为政策的变动所担⼼，唯恐⾃⼰的努⼒化为泡影？还是选⼿。可他们同时也是最缺乏话语权的⼀批⼈，在跟⾃⼰的命运息息相关的这些事务中，这些选⼿却⼏乎不能产⽣任何影响。他们唯⼀能采取的有效⼿段就是更加拼命地埋下头去学习各种知识，⼒图使⾃⼰在下⼀场的竞争中拔得头筹，⽽之后等着他们的还有更多的竞争。（《整形溢出》，第134-135页。）</p><p>同学们。我们有主体性，我们有话语权，我们掌握知识，信息学归根究底是我们的。我们只不过是被困在二元对立的迷思和对世界与理想的刻板想象里，唯有实践，唯有学习，唯有反思，唯有交流，唯有创作，唯有开放，唯有严肃，唯有同情，才是通向未来的钥匙。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信&quot;&gt;&lt;a href=&quot;#关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信&quot; </summary>
      
    
    
    
    <category term="精华转载" scheme="https://q.billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>U盘里的文件夹突然变成了“应用程序”后缀名怎么办？</title>
    <link href="https://q.billma.top/2021/11/12/file-exe/"/>
    <id>https://q.billma.top/2021/11/12/file-exe/</id>
    <published>2021-11-12T11:47:58.000Z</published>
    <updated>2021-11-12T12:35:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学校电脑有很多老师喜欢使用U盘拷贝文件，但是我发现，许多老师的U盘都被感染上了病毒。这种病毒很常见，感染力极强，而且甚至像360系软件等等根本无法查杀。那么，这种病毒如何查杀呢？</p><h2 id="1-病毒介绍"><a href="#1-病毒介绍" class="headerlink" title="1.病毒介绍"></a>1.病毒介绍</h2><p>文件夹EXE病毒，学名Worm.Win32.AutoRun.soq。这种病毒只会运行在win32系统上。当你把你的U盘插入到一台电脑后，突然发现U盘内生成了以文件夹名字命名的文件，扩展名为exe，并且它们的图标跟windows默认的文件夹图标是一样的，很具有迷惑性。当你双击这个被伪装的exe文件后，木马自动启动并在电脑内下毒。</p><h2 id="2-运作原理"><a href="#2-运作原理" class="headerlink" title="2.运作原理"></a>2.运作原理</h2><p><strong>简而言之，这个病毒就是将你原有的文件夹隐藏起来，然后制造一个exe文件伪装成你的文件夹，其实这个exe就是病毒。在“组织”中，勾选“显示被隐藏的文件和文件夹”，并且取消勾选“隐藏被保护的文件夹”即可看到你的文件夹。</strong></p><p><em><strong>完整病毒机理：</strong></em></p><p>病毒运行后会释放以下文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">com.run </span><br><span class="line">dp1.fne </span><br><span class="line">eAPI.fne </span><br><span class="line">internet.fne</span><br><span class="line">krnln.fnr</span><br><span class="line">og.dll</span><br><span class="line">og.edt </span><br><span class="line">RegEx.fnr</span><br><span class="line">fne </span><br><span class="line">spec.fne </span><br><span class="line">ul.dll</span><br><span class="line">XP-<span class="number">290</span>F2C69.EXE（后<span class="number">8</span>位随机）</span><br></pre></td></tr></table></figure><p>这些文件会被复制到系统盘的C:\WINDOWS\system32里面</p><p>随后，新增以下注册表项，以达到病毒随系统启动而自启动的目的。</p><p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code></p><p>注册表值：XP-290F2C69（后8位随机）</p><p>类型：REG_SZ</p><p>值：C:\WINDOWS\system32\XP-290F2C69.EXE（后8位随机）</p><p>添加以下启动项，实现病毒自启动：<code>“C:\Documents and Settings\Administrator\「开始」菜单\程序\启动” 里的“　.lnk”</code>指向病毒文件。</p><p>下载病毒文件： （16,896 字节）保存为以下文件，并且运行它们：<br><code>%Windir%\System32\winvcreg.exe</code></p><p><code>%Windir%\System32\2080.EXE (名称随机)</code></p><p>然后，被感染的电脑接入移动磁盘后，病毒会遍历移动磁盘根目录下的文件夹，衍生自身到移动磁盘根目录下，更名为检测到的文件夹名称，修改原文件夹属性为隐藏，使用户在其他计算机使用移动磁盘打开其文件夹时运行病毒， 以达到病毒随移动磁盘传播的目的。</p><h2 id="3-解决办法："><a href="#3-解决办法：" class="headerlink" title="3.解决办法："></a>3.解决办法：</h2><h3 id="1-杀毒软件"><a href="#1-杀毒软件" class="headerlink" title="1.杀毒软件"></a>1.杀毒软件</h3><p>360并不能查清此病毒，建议使用毒霸或者电脑管家查杀。注意，该方法只能清除病毒，但不能显示被隐藏的文件夹。</p><h3 id="2-手工清除"><a href="#2-手工清除" class="headerlink" title="2.手工清除"></a>2.手工清除</h3><p>1、结束病毒进程。打开任务管理器，选择进程，结束进程XP-290F2C69.EXE（后8位随机），winvcreg.exe，2080.exe（随机名）。</p><p>2、删除病毒在System32生成的以下文件：</p><p><code>com.run dp1.fne eAPI.fne internet.fne krnln.fnr og.dll og.edt RegEx.fnr fne spec.fne ul.dll XP-290F2C69.EXE winvcreg.exe 2080.EXE（随机名）</code></p><p>3、删除病毒的启动项，删除以下启动项：</p><p><code>“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run”里的XP-290F2C69.EXE（后8位随机）</code></p><p><code>“C:\Documents and Settings\Administrator\「开始」菜单\程序\启动” 里的“　.lnk”</code></p><p>4、清除你的点击“开始”—输入“cmd” ，进入命令提示符，然后进入你U盘所在的根目录，具体操作如下，比如你的U盘盘符位G(即你的U盘在G盘），那么依次运行如下命令（第一行的“G:”为你的U盘盘符）：</p><p><strong>注意：第二句话会删除根目录下包括非病毒在内的所有exe文件，谨慎使用，可以仅使用1、3句话然后手动删除exe文件夹</strong></p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d G:</span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; %a <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /ad&#x27;) <span class="keyword">do</span> (<span class="built_in">del</span> /a /f /q &quot;%a.exe&quot;) </span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; %a <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /adh&#x27;) <span class="keyword">do</span> (<span class="built_in">attrib</span> -s -h -r &quot;%a&quot;)</span><br></pre></td></tr></table></figure><p>这一步也可以用C++来代替：（不会清除其他文件）</p><p>首先删除你跟目录下所有exe文件夹，随后使用此代码：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;windows.h&gt;void listFiles(const char * dir);int main()&#123;    using namespace std;    char dir[100];    cout &lt;&lt; &quot;Enter a directory (ends with \&#39;\\\&#39;): &quot;;    cin.getline(dir, 100);    strcat(dir, &quot;*.*&quot;);       listFiles(dir);    return 0;&#125;void listFiles(const char * dir)&#123;    using namespace std;    HANDLE hFind;    WIN32_FIND_DATA findData;    LARGE_INTEGER size;    hFind = FindFirstFile(dir, &amp;findData);    if (hFind == INVALID_HANDLE_VALUE)    &#123;        cout &lt;&lt; &quot;Failed to find first file!\n&quot;;        return;    &#125;    do    &#123;        if (strcmp(findData.cFileName, &quot;.&quot;) == 0 || strcmp(findData.cFileName, &quot;..&quot;) == 0)            continue;        if (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)          &#123;            cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\t&lt;dir&gt;\n&quot;;             string str=&quot;attrib \&quot;&quot;;            str.append(findData.cFileName);            str.append(&quot;\&quot; -s -h&quot;);            system(str.c_str());                    &#125;        else        &#123;            size.LowPart = findData.nFileSizeLow;            size.HighPart = findData.nFileSizeHigh;            cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\t&quot; &lt;&lt; size.QuadPart &lt;&lt; &quot; bytes\n&quot;;        &#125;    &#125; while (FindNextFile(hFind, &amp;findData));    cout &lt;&lt; &quot;Done!\n&quot;;    system(&quot;Pause&quot;);&#125;输入你U盘所在盘符（例如 G:\) （\要反斜杠）即可</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近学校电脑有很多老师喜欢使用U盘拷贝文件，但是我发现，许多老师的U盘都被感染上了病毒。这种病毒很常见，感染力极强，而且甚至像360系软件等等根本无法查杀。那么，这种病毒如何查杀呢？&lt;/p&gt;
&lt;h2 id=&quot;1-病毒介绍&quot;&gt;&lt;a href=&quot;#1-病毒介绍&quot; class=&quot;</summary>
      
    
    
    
    <category term="日常经验" scheme="https://q.billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>孔子：黑暗王国里的残烛</title>
    <link href="https://q.billma.top/2021/10/30/zz_confuzi/"/>
    <id>https://q.billma.top/2021/10/30/zz_confuzi/</id>
    <published>2021-10-30T13:49:45.000Z</published>
    <updated>2021-10-30T14:07:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2]  、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>儒家者流。盖出于司徒之官，助人君顺阴阳明教化者也。游文于六经之中，留意于仁义之际，祖述尧舜，宪章文武，宗师仲尼，以重其言，于道最为高。——《汉书·艺文志》</p><p>士不可不弘毅，任重而道远。仁以为己任，不亦重乎！死而后已，不亦远乎！——曾参</p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>　　孔子的长相颇怪。“生而圩顶”，就是说，他天生的脑袋畸型，头顶上中间低，四周高，司马贞说，其形状恰像倒过来的屋顶。名之曰丘，固当。不知命相学家是如何解释的。这种头顶是否暗示着承受天地之甘露阳光？孔子自学而成大才，其天赋必然很高。而其身长亦不凡，“九尺有六寸”，这在那时可以说是“硕人”了，“人皆谓之长人而异之”，人人都说他是长人，感到惊异。真正的一个齐鲁大汉。不过，这个“长人”的身影也确实够长了——长到遮蔽了整个民族漫长的历史，—个民族都—直顺着他的倒影前行两干多年了，我们何时才能走出这漫漫的阴影呢?</p><p>　　据司马迁和《孔子家语》的记载，孔子乃是商代“三仁”之一微子的后代。那个有名的“仁义之师”的统帅宋襄公，便是他的十一世祖——难怪他也像宋襄公那样泥古不化，自讨苦吃。用古老的仁义道德去对付现世的流氓强盗，这也是他家族的祖传秘诀吧，只可惜常常不灵。到孔子的六世祖孔父嘉，“五世亲尽，别为公族”，不再属王族，姓也成了“孔”。后来孔父嘉又为人所逼而奔鲁。所以孔子确实是一位“没落贵族”。到他父亲叔梁纥，便是连人丁也很寥落了：正妻连生九女，—妾生子叫孟皮，却又是个跛子。年近七十的叔梁纥大概非常绝望了。但他还要作最后的努力，于是便向颜氏求婚，颜氏少女颜征“从父命”而嫁给了古稀之年的叔梁纥。所以，司马迁说这是“野合”，“野”与“礼”相对，夫妻双方年龄差别太大，不合周礼，所以这婚姻不是“礼合”，而是“野合”。“野合而生孔子”——这实在太有意味了，为什么呢？孔子终其一生都在为“礼坏乐崩”而头疼，而愤怒，而奔走呼号，要人们“克己复礼”，孰料他本人即是个不合礼的产儿呢。如果他的那位老父亲真的克制自己来恢复周礼，可就没有孔子了。真玄哪。要知道，这不合“礼”的产儿，竟是他们这古老家族之链上最辉煌的一环，也是我们这古老民族历史上最辉煌的人物啊！</p><p>　　宋人说，“天不生仲尼，万古长如夜”。好抬杠的李贄就此讽刺道，怪不得孔子出生之前，人们都点着蜡烛走路。我想，话不能这么说，也不是这么说的。我觉得，孔子确实是悬挂在那个遥远古世纪的一盏明灯，他使我们对那个遥远的时代不再觉得晦暗和神秘，他使那时代的人与后代乃至于我们沟通了。我们由他知道，即便在那么一个洪荒时代，也是有阳光普照着而万物不探手段地生机勃勃；那时代也发生着我们今天一样的事情：暴力和弱者的呻吟；混乱和宁静的企望；束缚与挣扎；阴谋与流血；理想碰了钉子；天真遇见邪恶；友情温暖，世态炎凉。在他手订的《诗经》中，我们甚至可以体验到最个性的感受——当那些面孔不一情性各异的个人复活时，那个时代不也就复活了吗？<br>　　孔子生活的时代也真像他所说的，确实是混乱无道。他为之伤心不已：辉煌的“郁郁乎文哉”的周王朝已是日薄西山，伟大的周公早已英魂远逝，他制定的“礼”“乐”也土崩瓦解。“弑君三十六，亡国五十二”，到处都是乱臣贼子，且个个生龙活虎。西周古都废墟上的青草与野黍也一茬一茬地青了又黄，黄了又青，根深而茎壮了，掩埋在草丛中瓦裂的陶器早已流尽了最后一滴汁液。九鼎不知去向，三礼流失民间。东周呢？龟缩在洛邑弹九之地，可怜巴巴地看着那些纵横天下的伯霸诸侯，把九州版图闹得瓜分而豆刮。</p><p>　　无可奈何花落去，还有谁来用红巾翠袖，擦去周王混浊的老泪？连孔子本人都不曾去那里。在这种时候，要“兴灭国，继绝世，举逸民”，真无异于痴人说梦。孔子正是这样的一位痴人。痴人往往缺乏现实感。他的精神就常常脱逸出现实的背景，沉浸在过去的辉煌中，追寻着万物逝去的方向。是的，他一生都在追寻，他周游列国，颠颠簸簸，既是在找人，找一个能实施他主张的人，更是在找过去的影子，找东周昔日的文明昌盛。面对这一伟大帝国的文化废墟，孔子领悟到并承诺了自己的使命！但挽狂澜于既倒，或知其不可而为之，只不过是一种令人钦敬的悲剧精神罢了，他最终还是失败了。当他奔波倦极归来，在一条小河边饮他那匹汗马时，他偶然从平静的流水中惊见自己斑驳的两鬓，“甚矣，吾衰矣”（太惨啦！我已经衰老了！）他顿时心凉如水。这衰弱的老人，他的多少雄心都失败了，多少理想都破灭了。壮志不酬，眺望茫茫无语的宇宙，他心事浩茫。人世渺小，天道无情，青山依旧，哲人其萎。于是，一句意味深长的叹息便如一丝凉风，吹彻古今：“逝者如斯夫！”</p><p>　　我在几千年后的漆黑的夜里写这篇文章时，宛如见到他当初衰弱地站在苍茫高天之下的无情逝水边。那无限凄惶的老人的晚景使我大为感动。于是这篇文章的题目也就一闪而现了：这衰弱的，即将随着时间的流水逝去的老人，不就像黑暗旷野上快要燃尽的一枝蜡烛吗？四面飚风，寒意四逼，这支蜡烛艰难地闪耀……</p><p>　　孔子死后，鲁哀公装模作样地悲痛一番，悼念一番，他写了一篇诔文，似乎感伤得很：“上天太不公平啦。不肯留下一位老人陪我，让我一人在鲁国孤零零的，唉，多么悲痛。”孔子的弟子子贡毫不客气地顶了回去：“生不能用，死而诔之，非礼也！”</p><p>　　其实，对孔子“生不能用”的，岂止—位鲁哀公呢？孔子一生见过不少诸侯，像楚昭王，齐景公，卫灵公……等等，有谁用他呢？天下人事纷纷扬扬，新生事物层出不穷，人人都在玩新花样，搞新名堂，他老先生拿着一把过时的且是万古不变的尺子，东量量，西测测，这也不合“礼”，那也不合“乐”，到处招人惹人，别人对他敬而远之也是很自然的。同时他又像一个蹩脚的推销员，推销过时的、早已更新换代的产品。这产品不是按顾客的需求而设计，而是要以这产品的规格来设计顾客，正如韩非嘲笑他的，不是根据脚的大小来选鞋，而是根据鞋的大小来“削足”。他这么不合时宜，被人拒绝不是很正常的么？子贡以他的经济实力和外交天才，到处为老师打点鼓吹，也没有什么效果。子贡的悲痛心情是可以理解的，但过分责备鲁哀公不能用孔子，就不大合情合理啦。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉！吾从周！”“逝者如斯夫！”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到—种温软，一种熨帖，这实在是让我们大大舒了—口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。</p><p>　　孔子使一些无序的暴力变成了有目的有方向的努力与企望，他使天下英雄入于他的彀中，并带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往往显示出一种蓬蓬勃勃、生机无穷的魅力。春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想，充满激情，充满公理仁德的时代吗？谁开辟了这样的时代？是孔子。非常具有象征意义的是，当孔子和弟子们周游列国的时候，他往往自己驾车——他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天，一脸凄迷与怀疑，只有他永远目光炯炯，自信目标就在前方。</p><p>　　有一次，在一条汤汤而流的小河边他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。<br>　　其中的一个细长个子却不回答子路的询问，而是反问子路：</p><p>　　“那个执缰绳的人是谁？”</p><p>　　子路恭敬地回答：“是孔丘。”</p><p>　　“是鲁国的那个孔丘吗？”——可见孔子的知名度颇高。</p><p>　　子路答：“是”。这个细高个冷冷的就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛”。</p><p>　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能按捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁？”</p><p>　　子路仍然是恭敬地回答：“我是仲由。”</p><p>　　“你是孔丘的门徒吗？”</p><p>　　“是。”</p><p>　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面？我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好！”</p><p>　　这里我先解释两个词。什么叫“避人”呢？避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他恓恓惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”？在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望；从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。</p><p>　　再回头说子路被这两人教训得一愣一愣的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完，不尽的迷惘。谁说这两位隐士说得不对呢？这不也是孔子自己内心中常有的感触吗？但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗？他有教无类，诲人不倦，门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗？于是他感慨万端：“人总不能与鸟兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和谁生活在一起呢？他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗？假如天下有道，还需要我们吗?”</p><p>　　《论语》中的这一段，很传神，两千多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。他恓惶而寂寞，迷惘而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他问稼，问为圃，大概也是准备避世了吧。望望眼前，路漫漫其修远兮，看看身后，追随者渐渐寥落。“道不行，乘桴浮于海，从我者，其由与！”（道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的，可能只有一个仲由了吧！）<br>　　这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者”（我从未见过一个喜爱德行比得上喜爱美色的人。）“吾未见刚者”（我未见过刚强的人）“吾未见好仁者，恶不仁者”，（我未见过喜好仁厌恶不仁的人）“末闻好学者”（没听说过好学的人）。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗？要让这些弟子们“无欲则刚”、“好德如好色”都不可能，更何况别人？韩非就曾刻薄尖酸地揶揄孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么？而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向慕仁义的人是多么少啊。孔子此时的处境，真是令人同情。</p><p>　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”（三军可以更改主帅，匹夫却不能逼他改变志向）。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容玷污？天下一团漆黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行！我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意孤行的人必有大精神，大人格。</p><p>　　一位楚地的狂生曾经警告过孔子：“往者不可谏，来者犹可追。已而已而，今之从政者殆而！”（你过去糊涂就算了，以后你可改了吧！算了吧算了吧！现在追随政治危险得很啦！）但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”——政治，就是对暴政的矫正！就是正义！所以，孔子庄严宣告：“志士仁人，无求生以害仁，有杀身以成仁。”虽然他也说过“危邦不入，乱邦不居，天下有道则见，无道则隐”之类的话；虽然他也称赞蘧伯玉：“邦有道则仕，邦无道则卷而怀之”，宁武子“邦有道则知，邦无道则愚”，并慨叹“其知可及也，其愚不可及也”（他的聪明别人是比得上，他的糊涂别人就比不上了），大有郑板桥“由糊涂入聪明难，由聪明入糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史鱼一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样，正道直行，永不回头。</p><p>　　自魏晋以后，中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之、闭目养神的隐君子！他们的伦理关怀哪里去了？他们的道德痛苦哪里去了？作为知识分子，他们的基本人道精神哪里去了？难道我们不应该要求知识分子有起码的价值关怀吗？但我们却偏偏认为他们是涵养最高、道德最纯洁的人！鲁迅禁不住对这些人怒形于色：泰山崩，黄河溢，隐士目无见，耳无闻！这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭桶酒囊茶壶甚至权势的尿壶么！现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>　　孔子的哲学核心是“仁”。在《论话》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁”没有“一以贯之”的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。</p><p>　　“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能”求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是，造次必于是”，何曾有—丝—毫的媚俗之态！他正大光明，磊磊落落，他一意孤行，坦坦荡荡。</p><p>　　他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做！他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了，而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心？不辉煌何以长人志？但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投入是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。</p><p>　　孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定？因为他们任重道远。为什么说他们任重？因为他们是把仁当作自己的人生责任的；又为什么道远？因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么—个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次！</p><p>　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：</p><p>　　子路从而后，遇丈人。以杖荷蓧。</p><p>　　子路问曰：“子见夫子乎？”</p><p>　　丈人曰：“四体不勤，五谷不分，孰为夫子？”植其杖而芸（耘）。</p><p>　　子路拱而立。</p><p>　　止子路宿。杀鸡为黍而食之。见其二子焉。</p><p>　　……</p><p>　　子路曰：“不仕无义。……欲洁其身而乱大伦！君子之仕也，行其义也。道之不行，已知之矣。”</p><p>　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗？减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗？我们这个民族的历史与文化会因此更加辉煌灿烂吗？我们这个“文明古国”就会更加文明吗？</p><p>　　另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗？或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗？这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗？如果不是这样，他即使证出了1+2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗？我的这种问法不是没有道理的，二十多年前，我们就这么干过。否则，要办那么多的“干校”干什么?</p><p>　　樊迟问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗？孔子的回答：“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来？你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院生问博士生导师吗？</p><p>　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸（耘）”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子比呢？他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耘的是什么荒？是文化之荒！所培养的是什么苗？是文化之苗！柳诒徵《中国文化史》云：</p><p>　　孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔子而传，自孔子以后数千年之文化赖孔子而开。</p><p>　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量？又如何是小农思想满脑子的人所能理喻、所能批评的？</p><p>　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人孱弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器，对铁器时代绿林好汉手中青锋长剑的批评。</p><p>　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而麋集到周作人羽翼下的一些人，他在这个社会里占有了比别人好—些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必至少有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说，他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的，掩盖自己的智慧，就是对社会的背叛；隐匿自己的发现，就是对社会的犯罪——当然，这种行为在专制社会里可能是迫不得已的。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>　　因为怕孔子到楚国后说陈蔡诸侯的不是，陈蔡的小政客们便把孔子围在郊野。小政客毕竟是小政客，他们把孔子围住后，却拿不准到底要怎么样。面对一位文化巨人，他们的内心毕竟很虚怯。他们很憎恨孔子文化人格的光芒，所以，他们把他包围起来，试图挡住这光芒的四射，但他们又绝没有胆量去迫近光源——于是在陈蔡之野，便有了这样一种既滑稽又尴尬的场面：里面的人出不去，外面的人也不进来。彼此都迫切希望有一个第三者出现，来给大家一个台阶下。在第三者楚昭王派兵迎接孔子之前，孔子和他的弟子们在饥肠辘辘与满脸菜色中进行一番有趣的对话，其主题是讨论道与势的关系。</p><p>　　孔子的知音司马迁在记叙这一段历险时，把孔子的人格精神写得淋漓尽致。据司马迁记载，此时的孔子，有意识地利用这次挫折，来考验、考查弟子们对道的忠诚贞定。孔子先叫来子路，问他：“难道我的主张不对吗？我为什么落得这个下场？”忠厚的子路疑疑惑惑地说：“是不是我们还不仁呢？人们不信任我们？是不是我们还不智呢？人们不放心我们？”悲愤的孔子说：“仲由啊，你听着，假使仁义的人一定受信任，怎么会有饿死首阳山的伯夷和叔齐？假使智慧的人一定行得通，怎么会有被纣王挖腹剖心的王子比干？”子贡进来了，孔子用同样的问题问他，子贡说：“老师，你的道太伟大了，所以这狭隘的世界容不了你。你能不能稍微降格以求呢？”孔子说：“赐啊，好的农夫只问耕耘不问收获，好的工匠只追求技巧而不追求苟顺人意，作为君子，修习大道，是不能讲苟合的啊。”</p><p>　　最后是颜回入见，这位比孔子小三十岁的小学生，聪慧谦让，悟性高，不爱显山露水，能过苦日子，深受孔子的喜爱。他的回答，令先生愁肠顿开：“夫子之道至大，故天下莫能容。虽然，夫子推而行之，不容何病？不容然后见君子！夫道之不修也，是吾丑也，夫道既已修而不用，是有国者之丑也。不容何病！不容然后见君子！”孔子欣然而笑，说：“说得好啊，颜家小于！将来你发财时，我给你赶车吧！</p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了，不能再奔波了，况且奔波又有什么收获呢？于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰，但心如止水却是必然的。鲁君无意用他，他也懒洋洋的不求用了。回到自己阔别多年的老屋，撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了，乱臣贼子们活得更神气了，但也令他更无奈了。宝剑折断，铩羽而归，他还能做些什么呢？他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后，他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后，他的影响力却遍及全世界，名声响彻天下。</p><p>　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公一样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉！”（君子很惧怕死后没有名声留传啊）于是他便想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。“三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”，而为后世不断地钻研，又在这不断的琢磨中发出历久弥新的光芒。</p><p>　　那本“饥者歌其食，劳者歌其事”的三百零五首“诗”，记录着那么遥远时代的真切的痛苦，更是因为他的手订，由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之首，“子曰”与“诗云”并称。实际上，就是因为“孔子曰”，孔子的赞誉，《诗》中愚夫愚妇们的“云”，才成为中国古代文学的圣经。他对这三百首《诗》说过些什么呢？他和子夏讨论过“巧笑倩兮，美目盼兮”；他和子贡讨论过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说，“《诗》可以怨”！他把《诗》当作教材，传授给弟子们，正是因为这种口耳相传式的传授，才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火，斯文不灭。他还庄重地为《诗》回护，说：“《诗》三百，一言以蔽之，曰思无邪！”这就使后世很多对《诗经》暗怀不满的人，比如朱熹，只能做些鬼鬼祟祟的歪曲的勾当。孔子是文学的守护神呢。原来他不仅是一位庄严谨恪的人，还是一位情感丰富的人！因此，他不仅要求人类要有道德，就是对人类的情感——包括对人性的弱点，他也有那么多善意的回护与爱惜！他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。</p><p>　　说到这里，插入一件小事。跟孔子学语言修辞的子夏，有一个毛病，那就是吝啬。知生莫如师，孔子深知子夏这一毛病，于是就刻意为他遮掩。一次孔子出门，碰上下雨，而子夏有伞，孔子却不去借，甘冒雨淋之苦。有人问孔子为何不问子夏借伞，孔子说，子夏有这个小毛病，若向他借伞，借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗？如果能掩盖住别人的缺点，我淋点雨算什么呢？</p><p>　　文学是人学，文学就是人性的表现。不能对人性的优点有极崇高的敬意，对人性的弱点有极宽厚的怜悯，是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有一丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人（这就是“乐而不淫”），做了妻子后她辛勤贤慧，但最后还是被抛弃了，即便这样，她也依然那么理智，节制，哀而不伤，怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”（唉，算了吧），是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理，但我觉得这才合情。美狄亚就实施了惨烈的报复么。孔子也提倡“以直报怨”么。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙，很没有人性。他说：“此淫妇为人所弃，自叙其事以道其悔恨之意也”（这个淫荡的女子被别人始乱终弃了，自己追叙自己的所作所为，倾吐出悔恨之意）”读到这样的议论如果不觉得朱熹卑鄙下流，就不是正派人。因为朱熹凭空污人清白（在这首诗中一点也看不出这个女子有什么淫荡的地方）；他对一位多情的恋人（婚前）一个贤淑的妻子（婚后）毫无首肯之意，理学家之不懂欣赏女人，于此可见一斑，而理学家之仇视—切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知“以理杀人”的后儒们，他们何曾及得上孔子的一分—毫啊。</p><p>　　由于孔子丰富的文学情怀，他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己，而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑戟，而是更加的幽默生动。你看他说的：“志于道，据于德，依于仁，游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是“成于乐”而“游于艺”！他一下子变得亲近了，不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么？他是一位手之舞之、足之蹈之的老顽童哩！他极爱音乐，即便在围困之中，也是每日“弦歌不衰”，只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件轶事：他在师襄子那里学了一首曲子，一连弹了十数天还不换其他曲子，直到他从这首曲子里“听”出了那个肤色黝黑、身材顾长、眼神忧郁的文王的形象！“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人么？孔子的精神通过飞翔的音符而与之相通了！</p><p>　　有这样的音乐修养与音乐情怀，“三百五篇孔子皆弦歌之。”这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了，“此曲只应天上有，人间哪得几回闻”。但那古老而简朴的文字仍留传下来，那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活，是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……</p><p>　　《诗经》中有一百六十首都是采自民间，包括黄河流域，汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘陇与庄稼，贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢？还有什么比这更快乐的工作呢？</p><p>　　——冬日的蛰居过去了，春光融融，芳草萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……</p><p>　　我在村落间徘徊，看顽童嬉闹；我亦走上田头，看麦苗油油，静观灌溉之水汩汩流淌。</p><p>　　多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了，哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……</p><p>　　在还处飘来的歌声面前，我老泪纵横。</p><p>　　我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时，他不也是感怀万端呢？“四方有羡，我独居忧。民莫不逸，我独不敢休”（《十月之交》），这样的句子，如此贴切他忧患人生的情怀，如此真切地反映他奔波为天下的辛苦，他能不感慨吗？而那一位走过周朝旧都，面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗？面对伟大朝代的文化废墟，他不更是忧患满怀吗？“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉？”（《黍离》），是啊，孔子，他是—位什么样的人呢？</p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>　　《尚书》之流传具有传奇色彩，我们今天读到的本子乃是东晋豫章内史梅赜所献的《孔传古文尚书》。这个“孔”字乃是孔安国，司马迁的老师。他也是孔子的十一代孙。而这个孔安国所传的《尚书》，乃是汉鲁共王从孔子故居的墙壁中得到的。光这—点，就可知孔子与《尚书》之关系了。</p><p>　　如果说《诗经》是中国历史上最早的诗歌总集，那么，作为“上古之书”的《尚书》乃是中国历史上最早的散文集。同时，如果说《诗经》是民间的（风、雅都可以算作是民间的），那么《尚书》就是朝廷的。《诗》是民间的情感，《书》是朝廷的意志。《诗》是抒情的，《书》是理智的。《诗》是散漫的，《书》是约束的。</p><p>　　《诗》唱个性感受，《书》倡国家价值。《诗》是艺术，《书》是道德。《诗》是大地，是天空，是大地上的野花，是天空中的飞鸟；《书》是庙宇，是碑石，是庙宇中的祖训．是碑石中的缄言。《诗》是音乐《书》是建筑，谢林说，音乐是流动的建筑，建筑是凝固的音乐。没错，《诗》是意志的流动，《书》是情感的凝固……我们民族最古老最本质的东西，都积淀在《诗》、《书》之中了。它们都与孔子有关。</p><p>　　《易》据说最初乃是“大墙文化”，乃是周文王为商纣所拘押，在狱中无聊，又担心自己就此玩完，“没世而名不称”，推演而成。但文王的《周易》，纯属卜筮之书，对一般读者不啻天书。“孔子晚而喜易，序《彖》，《系》，《象》，《说卦》，《文言》，谈《易》，韦编三绝”（《史记》）。他的研究成果，经口授学生，学生整理成册，始有“十翼”，翼者，辅翼，辅助理解也。应该说，孔子是把卜筮之书改造成了哲学之书，综合天地人，探究天道人道，从“究天人之际，通古今之变”而“成一家之言”。所以，就《易》在这个意义上影响中国传统文化，我们又是在这个意义上理解《易》，毋宁说，《易》乃是孔子的著作了。孔子晚年，一边穷年兀兀以研《易》，一边却又担心时不我与，叹息道：“假我数年，若是，我于《易》则彬彬矣”。天不灭斯文，孔子而后，《易》果然彬彬而盛。“易者，易也，不易也。”这截然不同却又相辅相承的训释，恰好表明了天道人道的反复，变与不变的统一。《诗经》说：“鸢飞戾天，鱼跃于渊”（《早鹿》）《易》言：“天行健，君子以自强不息”“天地之大德曰生”，这是一个生机盎然蓬勃如斯的宇宙，这也是一个满腹忧患、自强不息的人生！</p><p>　　《礼》《乐》亦是孔子的教化工具。孔子对枯燥乏味的周代官制、礼仪的记录《仪礼》进行研究，指出其内涵、作用与本质。这一切都不过是“托古改制”而已。孔子说：“夫礼，先王以承天之道，以治人之情”，仍然是天道与人道。伟大的周公盛世初建，创建周礼，规范一个大帝国的行为与思想，开创了灿烂的周文化；伟大的孔子身当乱世，礼崩乐坏，他所做的，乃是在文化废墟上的考古、整理与保存。帝国的庞大躯体，已然僵仆，他已不能使之复生，他能做的乃是使帝国的精神与文化长存人间。他所唱的，乃是伟大文化的挽歌，世运不可回，人事有兴替，挽歌者，挽留之歌也！</p><p>　　在《礼运》的记载中，孔子根据可考历史的发展情况，预见着未来的道路。他认为，人类社会之发展经历着三个阶段：据乱世，升平世和太平世。据乱世就是他所处的时代了，而他为后人设想的“太平世”是什么样子呢？<br>　　天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子。使老有所终，壮有所用，幼有所长，鳏寡、孤独、废疾者皆有所养；男有分，女有归。</p><p>　　谁说孔子只是向后看呢？他也展望未来啊！只是这位衰弱的老人自知自己是等不到那黄河清的一天了！</p><p>　　《乐记》也还是在谈哲学，谈政治：</p><p>　　(音乐)清明象天，广大象地。终始象四时，周还象风雨……乐行而伦清，耳目聪明，血气和平，移风易俗，天下皆宁。</p><p>　　好像不能一味指责孔子把文艺都搞成道德教化，都搞成政治蓝图。你看他所处的是什么时代？一个“仁以为己任”的思想家，他不关心天下不宁，还关心什么？他不祈望天下皆宁并为之奋斗，他还祈望什么？让他回到家里，关上门，温壶春酒，泡杯苦茶，弹琴逍遥吗？</p><p>　　最后就要谈到《春秋》了。这是使一个时代都因此而得名的著作。</p><p>　　晚年的孔子顾视日影，喟然叹息：“不行啊不行啊，君子很惧怕死后没有留下名声啊。我的道行不通了，我凭什么在后世传名呢？”他搬来鲁国历代太史记录的史料，开始著作历史。以前在做官审案时，他很谦虚地与其他陪审官商定判辞，而此时他却突然“专断”起来，“笔则笔，削则削，子夏之徒不能赞一辞”。连插嘴提建议的机会都不给！这本以“微言大义”著称的历史著作，孔子是有意把它写成政治学著作、伦理学著作的！他在这里要审判的，是整个历史！而且他所进行的不止是历史批判，更重要的倒是他的政治批判与道德批判！他希望他的这本书能成为人的道德准则，更希望它能建立一种合理有序的政治运行法则。这就是这本书使“乱臣贼子惧”的原因。</p><p>　　孔子在给弟子们讲授《春秋》时感慨地说：“后世知丘者以《春秋》，而罪丘者亦以《春秋》。”丘吉尔说，影响历史的最好方法就是写历史，“春秋”以后的历史，不都受着《春秋》的影响么？孔子一直在参与着历史进程啊。只是他本人没有到场罢了，对后来的历史而言，他只是一个缺席者。</p><h2 id="七"><a href="#七" class="headerlink" title="七"></a>七</h2><p>　　我认为，孔子最伟大的贡献乃是他的“私学”。最初开办私学的人未必就是孔子，但把私学办成传授文化、培养人格、培养知识阶层的场所，则毫无疑问是孔子。正是在他的私学里，才出现了中国历史上第一批真正意义上的知识分子。——这些人既不是世袭贵族，也不是后来的科举士大夫，他们不是官僚机构中的成员。他们是那时代冒出来的“新人”，名称叫“士”，后来孟子宣称“大德者不官不王”，魏文侯之师田子方宣称“行不合，言不用，则去之楚越，如脱屦然。”可以见出这些人的傲慢与偏见——对诸侯的傲慢是那么显眼，对学问的偏见又是那么深固。</p><p>　　谁培养了这一批特行独立的知识分子？是孔子。上引的孟子与田子方都是孔门后学。所以，孔子的私学促成了文化的独立，文化由权势者股掌之间的小妾，蜕变为特行独立的汉子，“大丈夫”（孟子语）。这种文化不以取悦权势换得宠爱为目的，而以社会批判为天职。文化而以社会批判为天职，这就是文化的本质属性了。谁赋予了文化这种本质属性？是孔子。对于世俗政权而言，权力体制自身的制衡是必要的，重要的；而文化批判所产生的文化制衡尤其重要。中国后来漫长的封建社会里，之所以没能在权力体制之中产生制衡，这与封建政权把文化纳入权力体制，取消其独立性，否定其文化批判的必要性合理性有极大的关系。也就是说，当我们否定了文化批判之后，权力内部的制衡也就相应的被消解。官僚系统之内的权力制衡是为了政府及其各职权部门行为的合法有序及防止权力滥用；而文化批判所产生的制衡则是保证整个社会的行为合乎人性，合乎理性。孔子以后的百家私说，不都是在这个意义上讨论世俗政权的合理性么？</p><h2 id="八"><a href="#八" class="headerlink" title="八"></a>八</h2><p>　　孔子曾描述过自己的形象，“学而不厌，诲人不倦，不知老之将至”。在他的身边，一批勤奋好学安贫乐道的年轻人在成长着。看看这些蓬勃的春花，他真的就想不到自己已是秋天的一枚黄叶？这句话我看应该这么理解，正是因为知道自己老冉冉而将逝，才抱定“朝闻道，夕死可矣”的信念与日逐走，学而不厌。同时又把自己的心得传授给弟子们，诲人不倦他已是明白地知道，自己来日无多了！鲁迅晚年自知不久于人世，便一再告诫自己要“赶紧做”。孔子也是在与自己的生命赛跑，赶紧做呵。“天下无道久矣，而莫能宗予，”他已无力回天了，“道不行，乘桴浮于海”，他要离开我们去那道山了！</p><p>　　颜渊死了，他的精神受到沉重的打击。“天丧予！天丧予！（天要灭我，天要灭我啊！）安贫而乐道的颜回死于贫困，死后连棺材也没有。孔子为之深深恸哭。“我不为他哭还为谁哭呢？”他越来越老了，世道也越来越混乱了，不久，有消息传来，仲由死在卫国了，正中了孔子以前的忧心忡忡的预言：“不得其死”，被人剁为肉酱。仲由是众弟子中唯一敢于冲撞他的学生，小他九岁，总是雄纠纠的样子。孔子知道这个有些粗野的弟子其实最为忠厚义气，他还曾设想，当他远遁人世时，让仲由跟随着他。可现在又死在他前面了。他已经多次承受着这白发人送黑发人的惨痛了。他的心境更为凄凉了。做生意的端木赐（子贡）来看他，给老师一些周济，他正拄着拐杖在门外看西山的落日，那落日如血的余辉最后一次染红大地与天空。孤独的孔子问端木赐：“赐啊，你为什么到现在才来看我呢？”接着便低吟了一首绝命歌，那简单的字句和厚重的内涵使人想到宇宙中最简单而又最本质的哲理，人间的生死竟也牵动着宇宙的毁成：</p><p>　　太山坏乎！</p><p>　　梁柱摧乎!</p><p>　　哲人萎乎！</p><p>　　圣人洒泪而尽了。带着他的雄心去了。如蜡烛最后一次耀眼的一跳，熄灭了。天地之间，一片黑暗。但，也就是从那一刻起，他不再仅属于一个时代，而属于千秋万代！</p><p> 　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉!吾从周：”“逝者如斯夫!”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到一种温软，一种熨帖，这实在是让我们大大舒了一口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。孔子使一些无序的暴力变成了有目的、有方向的努力与企望，他使天下英雄人于他的彀中，带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往注显示出一种蓬蓬勃勃、生机无穷的魅力。</p><p>　　春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想、充满激情，充满公理仁德的时代吗?谁开辟了这样的时代?是孔子！非常具有象征意义的是，当孔子子和弟子们周游列国的时候，他往往自己驾车一一他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天．一脸凄迷与怀疑。只有他永远目光炯炯，自信目标就在前方。</p><p>　　有一次。在一条汤汤而流的小河边。他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。其中的一个细长个子却不回答子路的询问，而是反问子路：</p><p>　　“那个执缰绳的人是谁？”</p><p>　子路恭敬地回答：“是孔丘。”</p><p>　　“是鲁国的那个孔丘吗?”——可见孔子的知名度颇高。</p><p>　　子路答：“是。”这个细高个冷冷地就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛。”</p><p>　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁?”</p><p>　　子路仍然是恭敬地回答：“我是仲由。”</p><p>　　“你是孔丘的门徒吗?”</p><p>　　“是。”</p><p>　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面?我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好!”</p><p>　　这里我先解释两个词。什么叫“避人”呢?避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他栖 惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”?在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望，从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。</p><p>　　再回头说子路被这两人教训得一楞一楞的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完。不尽的迷悯。谁说这两位隐士说得不对呢?这不也是孔子自己内心中常有的感触吗?但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗?他有教无类，诲人不倦。门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗?于是他感慨万端：“人总不能与乌兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和淮生活在一起呢?他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗?假如天下有道，还需要我们吗?”</p><p>　　《论语》中的这一段，很传神，两干多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。惜惶而寂寞，迷悯而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他稼、问为圃，大概也是准备避世了吧。望望眼前。路漫漫其修远今，看看身后，追随者渐渐寥落。”道不行，乘俘浮于海，从我者，其由与!”(道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的、可能只有一个仲由了吧!)这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者’’(我从未见过一个喜爱德行比得上喜爱美色的人)“吾未见刚者”(我未见过刚强的人)“吾未见好仁者，恶不仁者”(我未见过喜好仁厌恶不仁的人)“末闻好学者’’(没听说过好学的人)。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗?要让这些弟子们“无欲而刚”“好德如好色”都不可能，更何况别人?韩非就曾刻薄尖酸地椰榆孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么?而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向幕仁义的人是多么少啊。孔子此时的处境，真是令人同情。</p><p>　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”(三军可以更改主帅、匹夫却不能逼他改变志向)。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容站污?天下一团混黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行!我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意现行的人必有大精神、大人格。一位楚地的狂生曾经警告过孔子：”往者不可谏，来者犹可追。已而已而，今之从政者殆而!”(你过去糊涂就算啦，以后你可改了吧：算了吧算了吧．现在追随政治危险得很啦：)但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”—一政治，就是对暴政的矫正：就是正义！所以孔子庄严宣告：“志士仁人，无求生以害仁，有系身以成仁。”虽然他也说过：“危邦不入，乱邦不居，天下有道则见，无道则隐’’之类的话；虽然他也称赞遽伯玉“邦有道则仕。邦无道则可卷而怀之”，宁武子“邦有道则知，邦无道则愚”、并慨叹“其知可及也，其愚不可及也”(他的聪明别人能比得上，他的糊涂别人就比不上了)，大有郑板桥“由糊涂入聪明难，由聪明人糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史色一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样、正道直行，永不回头。</p><p>　　自魏晋以后。中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之，闭目养神的隐君子!他们的伦理关怀哪里去了?他们的道德痛苦哪里去了?作为知识分子，他们的基本人道精神哪里去了?难道我们不应该要求知识分子以起码的价值关怀吗?但我们却偏偏认为他们是涵养最高，道德最纯洁的人!鲁迅禁不住对这种人怒形于色：秦山崩，黄河溢，隐士目无见，耳无闻!这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭捅酒囊茶壶甚至权势的尿壶么!现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。</p><p>　　孔子的哲学核心是“仁”。在《论语》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁’’没有“一以贯之’’的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰：“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能“求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是造次必于是”，何曾有一丝一毫的媚俗之态!他正大光明，磊磊落落，他一意孤行，坦坦荡荡。他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做!他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了．而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心?不辉煌何以长人志?但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投人是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎?死而后巳，不亦远乎?”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定?因为他们任重道远。为什么说他们任重?因为他们是把仁当作自己的人生责任的；又为什么道远?因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读 了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么一个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次!</p><p>　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：</p><p>　　子路路从而后，遇丈人。以杖荷條。</p><p>　　于路问曰：“子见夫子乎?”</p><p>　　丈人曰：“四体不勤，五谷不分，孰为夫子?”植其杖而罢(耘)。</p><p>　　子路拱而立。</p><p>　　止子路宿。杀鸡为泰而食之。见其二于焉。</p><p>　　子路曰：“不仕无义。……欲洁其身而乱大伦!君子之仕也，行其义也。道之不行，已知之矣。”</p><p>　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗?减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗?我们这个民族的历史与文化会因此更加辉煌灿烂吗?我们这个“文明古国”就会更加文明吗?另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗?或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗?这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗?如果不是这样，他即使证出了l十2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗?我的这种问法不是没有道理的，20多年前．我们就这么干过。否则，要办那么多的“干校”干什么?</p><p>　　樊迟向他问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗?孔子的回答是“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来?你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院问博士生导师吗?</p><p>　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸(耘)”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子相比呢?他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耕耘的是什么荒?是文化之荒!所培养的是什么苗?是文化之苗!柳绐徵《中国文化史》云：”孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔于而传，自孔子以后数千年之文化赖孔于而开。”</p><p>　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量?又如何是小农思想满脑子的人所能理喻、所能批评的?</p><p>　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人民弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器。对铁器时代绿林好汉手中青锋长剑的批评。</p><p>　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而庚集到周作人羽翼下的一些人，他在这个社会里占有了比别人好一些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说。他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的．掩盖自己的智慧。就是对社会的背叛：隐匿自己的发现，就是对社会的犯罪——当然．这种行为在专制社会里可能是迫不得已的。</p><p>　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了。不能再奔波了，况且奔波又有什么收获呢?于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰。但心如止水却是必然的。鲁君无意用他。他也懒洋洋的不求用了。回到自己阔别多年的老屋。撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了。乱臣贼子们活得更神气了。但也令他更无奈了。宝剑折断．铩羽而归，他还能做些什么呢?他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后．他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后。他的影响力却遍及全世界。名声响彻天下。</p><p>　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公…样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉!”(君子很惧怕死后没有名声留传啊)于是他使想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。”三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”．而为后世不断地钻研．又在这不断的琢磨中发出历久弥新的光芒。那本“饥者歌其食，劳者歌其事”的三百零五首“诗”。记录着那么遥远时代的真切的痛苦。更是因为他的手订．由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之百。“子曰”与“诗云”并称。实际上，就是因了“孔子曰”．孔子的赞誉。《诗》中愚夫愚妇们的“云”。才成为中国古代文学的圣经。他对这三百首《诗》通过些什么呢?他和子夏讨论过“巧笑倩兮，美目盼兮”：他和子贡讨沦过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说。“诗，可以怨”!他把《诗》当作教材。传授结弟子 们，正是因为这种口耳相传式的传授．才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火．斯文不灭—他还庄重地为《诗》回护。说：《诗》三百，—言以蔽之．曰思无邪！”这就使后世很多对《诗经》暗怀不满的人。比如朱熹．只能做些鬼鬼祟祟的、歪曲的勾当。孔子是文学的守护神呢。原来他不仅是—位庄严谨恪的人。还是一位情感丰富的人!因此，他不仅要求人类要有道德。就是对人类的情感——包括对人性的弱点。他也有那么多善意的回护与爱惜!他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。说到这里。插入一件小事。跟孔子学语言修辞的子夏，有—个毛病．那就是吝啬。知生莫如师。孔子深知子夏这一‘毛病．于是就刻意为他遮掩。一次孔子出门．碰上下雨，而子夏有伞。孔子却不去借，甘冒雨淋之苦。有人间孔子为何不向子夏借伞，孔子说。子夏有这个小毛病，若向他借伞。借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗?如果能掩盖住别人的缺点。我淋点雨算什么呢?</p><p>　　文学是人学，文学就是人性的表现。不能对人性的优点有极祟高的敬意．对人性的弱点有极宽厚的怜悯．是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有——丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。</p><p>　　《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人(这就是“乐而不淫”)，做了妻子后她辛勤贤患。但最后还是被抛弃了。即便这样，她也依然那么理智、节制，哀而不伤。怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”(唉，算了吧)．是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理。但我觉得这才合情。美狄亚就实施了惨烈的报复。孔子也提倡“以直报怨”。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙。很没有人性。他说：“此淫妇为人所弃．自叙其事以道其悔恨之意也。”(这个淫荡的女子被别人始乱终弃了．自己追叙自己的所作所为．倾吐出悔恨之意)读到这样的议论如果不觉得朱烹卑鄙下流．就不是正派人。因为朱熹凭空污人清白(在这首诗中一点也看不出这个女子有什么淫荡的地方)；他对一位多情的恋人(婚前)一个贤淑的妻子(婚后)毫无首肯之意，理学家之不懂欣赏女人．于此可见一斑，而理学家之仇视一切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知”以理杀人”的后儒们，他们何曾及得上孔子的一分一毫啊。</p><p>　　由于孔子丰富的文学情怀。他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己．而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑朝。而是更加的幽默生动。你看他说的：“志于道．据于德，依于仁、游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是”成于乐”而“游于艺”：他一下子变得亲近了．不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么?他是一位手之舞之，足之蹈之的老顽童哩!他极爱音乐．即便在围困之中，也是每日“弦歌不衰”。只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件软事：他在师襄子那里学了一首曲子．一连弹了十数天还不换其他曲子、直到他从这首曲子里“听”出了那个肤色黝黑、身材硕长、眼神忧郁的文王的形象!“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人吗?孔子的精神通过飞翔的音符而与之相通了!</p><p>　　有这样的音乐修养与音乐情怀。“三百五篇孔子皆弦歌之”。这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了。“此曲只应天上有．人间哪得几回闻”。但那古老而简朴的文字仍留传下来。那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活。是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……</p><p>　　《诗经》中有一百六十首都是采自民间。包括黄河流域。汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘垄与庄稼。贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢?还有什么比这更快乐的工作呢?</p><p>　　冬日的蛰居过去了，春光融融，芳香萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……</p><p>　　我在村落间徘徊．看顽童嬉闹：我亦走上田头。看麦苗油油，静观灌溉之水汩汩流淌。</p><p>　　那么多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了．哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……</p><p>　　在远处飘来的歌声面前，我老泪纵横。</p><pre><code>我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时．他不也是感怀万端呢?“四方有羡，我独居忧。民莫不逸，我独不敢休”(《十月之交》)，这样的句子，如此贴切他忧患人生的情怀．如此真切地反映他奔波为天下的辛苦，他能不感慨吗?而那一位走过周朝旧都．面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗?面对伟大朝代的文化废墟，他不更是忧患满怀吗?“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉?”(《黍离》)，是啊，孔子，他是…位什么样的人呢？</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2]  、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="精华转载" scheme="https://q.billma.top/categories/%E7%B2%BE%E5%8D%8E%E8%BD%AC%E8%BD%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>wenyan-compile</title>
    <link href="https://q.billma.top/2021/10/09/wenyan-compile/"/>
    <id>https://q.billma.top/2021/10/09/wenyan-compile/</id>
    <published>2021-10-09T14:54:01.000Z</published>
    <updated>2021-10-09T15:16:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、说在前面"><a href="#1、说在前面" class="headerlink" title="1、说在前面"></a>1、说在前面</h1><p>中考总分130分。其中古代诗歌默写6分，文言文阅读11分，古诗鉴赏4分。总共21分。</p><p>古代文学占17.5%</p><p>高考总分150分。文言阅读9分，翻译10分，古诗词鉴赏8分，古诗文默写8分。总共35分。</p><p>古代文学占21.3%</p><p>可见文言文是十分重要的。</p><p>然而。。。你想过用文言文编程吗？？？</p><p>这几年，奇奇怪怪的编程语言逐渐变多，其中一个学霸创建了一个叫文言文的编程语言，风靡github（？</p><h1 id="2、关于wenyan语言的代码与语法"><a href="#2、关于wenyan语言的代码与语法" class="headerlink" title="2、关于wenyan语言的代码与语法"></a>2、关于wenyan语言的代码与语法</h1><h2 id="2-1、认识wenyan语言"><a href="#2-1、认识wenyan语言" class="headerlink" title="2-1、认识wenyan语言"></a>2-1、认识wenyan语言</h2><p>咱们都知道，学习一门编程语言是从什么开始的？？</p><p>众OIer orz ：当然是 A+B~</p><p>哦，不对，学习一门语言应该先从理解这个语言的优缺点啊，基础框架啊等等（回想一下你刚开始学 C++ ， Pascal的时候（那时候我C++框架默了5遍都默错））。</p><p>但是! wenyan 语言 没有框架！</p><p>wenyan就像 Pascal一样，定义好变量后就直接开始打主代码了。不会像 C++一样还有什么万能头啊，什么 STL 啊，没有这么多,简单易懂（还能提升你的文言文阅读水平）。</p><p>现在，我们要开始打主代码，我们先从最基本的 Hello world!开始吧~</p><p>wenyan打三遍Hello world! 的输出是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吾有一數。曰三。名之曰「甲」。</span><br><span class="line">為是「甲」遍。</span><br><span class="line">吾有一言。曰「「問天地好在。」」。書之。</span><br><span class="line">云云</span><br></pre></td></tr></table></figure><p>编译为Javascript</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;問天地好在。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译为Python</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> _rand1 <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">_ans1=<span class="string">&quot;問天地好在。&quot;</span></span><br><span class="line"><span class="built_in">print</span>(_ans1)</span><br></pre></td></tr></table></figure><p> 编译为Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">3</span></span><br><span class="line">a.times <span class="keyword">do</span> <span class="params">|_rand1|</span></span><br><span class="line">_ans1=<span class="string">&quot;問天地好在。&quot;</span></span><br><span class="line">p([_ans1].join)</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure><p> 自译为c&#x2F;c++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;問天地好在。&quot;</span>);</span><br><span class="line">&#125;　</span><br></pre></td></tr></table></figure><p>运行：</p><p><code>問天地好在。問天地好在。問天地好在。</code></p><p>是不是很生动？很形象？对， wenyan 就是这样！清晰易懂，代码简便……</p><p>现在开始介绍 wenyan的基本语法:</p><h2 id="2-2、基本语法"><a href="#2-2、基本语法" class="headerlink" title="2-2、基本语法"></a>2-2、基本语法</h2><h3 id="2-2-1、定义变量"><a href="#2-2-1、定义变量" class="headerlink" title="2-2-1、定义变量"></a>2-2-1、定义变量</h3><p>毕竟都说是文言文编程了，肯定不能出现英文字母和数字的嘛~</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一數。曰六。名之曰「甲」。 int a（a就是甲）=6;</span><br><span class="line"></span><br><span class="line">有數六。名之曰「蒟蒻」。 int juruo=6;</span><br><span class="line"></span><br><span class="line">吾有一言。曰「「噫吁戲」」。名之曰「乙」。 string b（就是乙）=alas!</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2、ture和false"><a href="#2-2-2、ture和false" class="headerlink" title="2-2-2、ture和false"></a>2-2-2、ture和false</h3><p>true&#x2F;false 分别对应 wenyan语言中的陽&#x2F;陰（繁体的阳&#x2F;阴），类型就是“爻”（卦符的基本符号）：</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一爻。曰陽。名之曰「丙」。 bool c=true;</span><br><span class="line"></span><br><span class="line">吾有一爻。曰陰。名之曰「丁」。 bool d=false;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-3、if判断"><a href="#2-2-3、if判断" class="headerlink" title="2-2-3、if判断"></a>2-2-3、if判断</h3><p>作为一个编程语言怎么少了 ifi判断呢？</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">若三不大於五者。吾有一言。曰「「OK」」。 if(3&lt;=5) cout&lt;&lt;&quot;OK&quot;;</span><br><span class="line"></span><br><span class="line">書之。。若非。乃得「「NO」」也 else cout&lt;&lt;&quot;NO&quot;;</span><br></pre></td></tr></table></figure><h3 id="2-2-4、运算符"><a href="#2-2-4、运算符" class="headerlink" title="2-2-4、运算符"></a>2-2-4、运算符</h3><p>加减乘除一应俱全，连逻辑运算符都有!</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加一以一。 1+1</span><br><span class="line"></span><br><span class="line">除七以三。所餘幾何。 7%3</span><br><span class="line"></span><br><span class="line">減六六六六以六六六。名之曰「甲」。 int a=6666-666;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-容器类型"><a href="#2-2-5-容器类型" class="headerlink" title="2-2-5 容器类型"></a>2-2-5 容器类型</h3><p>容器类型也支持，而且注意一下，首个下标是从一开始的。</p><figure class="highlight plaintext"><figcaption><span>C++</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">吾有一列。名之曰「数组」。充「数组」以四。以二。 int shuzu[]=&#123;4,2&#125;;</span><br><span class="line"></span><br><span class="line">夫「寶劍」之長。 sword.size;</span><br><span class="line"></span><br><span class="line">夫「蒟蒻」之一。 juruo[1];</span><br><span class="line"></span><br><span class="line">夫「中国」之「「名」」。 China[&quot;name&quot;]</span><br></pre></td></tr></table></figure><h3 id="2-2-6-进价语法"><a href="#2-2-6-进价语法" class="headerlink" title="2-2-6 进价语法"></a>2-2-6 进价语法</h3><p>一些 wenyan 的进价语法。。。。。。</p><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><p>wenyan：<code>吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="定义含参函数"><a href="#定义含参函数" class="headerlink" title="定义含参函数"></a>定义含参函数</h4><p>wenyan：<code>吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a,b,c,d,e,f</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="定义其他函数"><a href="#定义其他函数" class="headerlink" title="定义其他函数"></a>定义其他函数</h4><p>wenyan：<code>吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">a</span>)&#123;<span class="keyword">var</span> b = a * <span class="number">2</span>; <span class="keyword">return</span> b;&#125;</span><br></pre></td></tr></table></figure><p>wenyan：<code>施「翻倍」於「蒟蒻」。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">double</span>(juruo);</span><br></pre></td></tr></table></figure><p>wenyan：<code>吾有一數。曰五。書之。</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="2-2-7-循环"><a href="#2-2-7-循环" class="headerlink" title="2-2-7 循环"></a>2-2-7 循环</h3><p>就是那些 for ， while循环之类的。（注意！ 云云 为 wenyan语言循环的后面必加的东西！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">為是百遍。⋯⋯ 云云。 <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)</span><br><span class="line"></span><br><span class="line">......恆為是。⋯⋯ 云云。 <span class="keyword">while</span>(<span class="literal">true</span>) ......</span><br><span class="line"></span><br><span class="line">乃止。 <span class="keyword">break</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目前就这些了……</p><h1 id="3、编写wenyan语言程序运行"><a href="#3、编写wenyan语言程序运行" class="headerlink" title="3、编写wenyan语言程序运行"></a>3、编写wenyan语言程序运行</h1><p>本人是用洛谷 IDE 进行运行的，当然还有一种网站也可以实现 wenyan语言的编译运行，还可以实现 wenyan转 JavaScript和 Python的功能！（虽然我都不会……）<br>这个网站就是：<a href="https://wy-lang.org/ide?example=beer">戳这里</a></p><p>这里面有不少好康和好玩的东西，你也可以在这里面编译。</p><p>而且项目文件还有个脚本src&#x2F;render.js，它可以把程序渲染成古代书籍的样子。</p><h1 id="4、关于wenyan语言编程"><a href="#4、关于wenyan语言编程" class="headerlink" title="4、关于wenyan语言编程"></a>4、关于wenyan语言编程</h1><blockquote><p>夫唐、虞之世，結繩而足治，屈指而足算。是時豈料百代之後，計算機械之巧，精於公輸之木鳶，善於武侯之流馬；程式語言之多，繁若《天官》之星宿，奇勝《山經》之走獸。鼠、蟹、鑽、魚，或以速稱。蛇、象、駱、犀，各爭文采。方知鬼之所以夜哭，天之所以雨粟。然以文言編程者 ，似所未有。此非文脈之所以傳，文心之所以保。嗟予小子，遂有斯志。然則數寸之烏絲猶覆於頭，萬卷之素書未破於手；一身長羁于远邦，兩耳久旷于雅言。然夫文章者吾之所宿好，程式者偶承時人之謬譽。故希孟不慚年少，莊生不望無涯。乃作斯言。未能嘔瀝長吉之心血，亦庶幾免於義山之流沫。既成之後，復學干將鑄劍而自飼，越王嚐糞而當先。自謂偶追《十書》之筆意，但恨少八家之淋漓。此子山所謂士衡抚掌而甘心，平子見陋而固宜。然則雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。此亦開源之大義，吾輩之所以勉勵也。一笑。 —-Huang Lingdong（wenyan语言作者）</p></blockquote><p>Huang Lingdong，来自卡耐基梅隆大学，如今大四，明年即将毕业。高中则毕业自上海世界外国语中学。</p><p>就是这个小伙子，做出了这个风靡 github的 wenyan语言！</p><h1 id="5、写在最后"><a href="#5、写在最后" class="headerlink" title="5、写在最后"></a>5、写在最后</h1><p>到最后，不知道大家看懂没（反正我是看懂了）。</p><p>真的是奇葩多。。。</p><h1 id="附录：奇奇怪怪的编程语言"><a href="#附录：奇奇怪怪的编程语言" class="headerlink" title="附录：奇奇怪怪的编程语言"></a>附录：奇奇怪怪的编程语言</h1><p>Esolang<br>Esoteric programming language，简称 Esolang，它们的设计被用于测试计算机语言设计的极限，作为一个概念的证明，或仅仅是一个玩笑。Esolang 创作者通常并不打算让它成为主流编程语言，他们几乎不会在意语言的可用性，甚至恰恰相反，会故意增加使用难度。（我介绍这个你们自己品）</p><p>比如 Brainfuck，它是在 1993 年被创造的编程语言，语法仅包含八种符号，没有任何单词，用它打印 Hello world 是这样的：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="title">[</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span>&gt;++<span class="literal">+</span>&gt;<span class="literal">+</span>&lt;&lt;&lt;&lt;<span class="literal">-</span><span class="title">]</span></span><br><span class="line">&gt;++<span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span><span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>&gt;++<span class="string">.</span>&lt;&lt;++<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="literal">+</span><span class="string">.</span></span><br><span class="line">&gt;<span class="string">.</span>++<span class="literal">+</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>--<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="string">.</span>&gt;<span class="literal">+</span><span class="string">.</span>&gt;<span class="string">.</span></span><br></pre></td></tr></table></figure><p>再比如 MarioLANG，它同样只能使用符号，需要使用形似马里奥关卡的语法来书写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">++++:     &gt;    &gt; +:+:+:+:+:+:+:::::</span><br><span class="line">====+    &gt;^=== &quot;&quot;&quot;=================</span><br><span class="line">    +:-):(:^= =                   !</span><br><span class="line">    =========  =                  #</span><br><span class="line">                = !         .+.,:-&lt;</span><br><span class="line">                 =###       ======&quot;</span><br></pre></td></tr></table></figure><p>Parenthesis Hell，言如其名，括号地狱，只能使用括号来书写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(()()(()()(()()()()((()()(()(()((()((()()()((()((()()()((()((((()()(()(</span><br><span class="line">)()()()()(((()(((()((()((((()(((()()(()()((()((()()()((()()(()()()()(()</span><br><span class="line">()()()(()()()()(()(())))))))))))))))))))))))))))))))))))))))))))))))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、说在前面&quot;&gt;&lt;a href=&quot;#1、说在前面&quot; class=&quot;headerlink&quot; title=&quot;1、说在前面&quot;&gt;&lt;/a&gt;1、说在前面&lt;/h1&gt;&lt;p&gt;中考总分130分。其中古代诗歌默写6分，文言文阅读11分，古诗鉴赏4分。总共21分。&lt;/p&gt;
&lt;p&gt;古代文学</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洛谷P5380鸭旗解法</title>
    <link href="https://q.billma.top/2021/10/05/cppluogu-p5380/"/>
    <id>https://q.billma.top/2021/10/05/cppluogu-p5380/</id>
    <published>2021-10-05T06:58:06.000Z</published>
    <updated>2021-10-05T07:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步-初始化"><a href="#第一步-初始化" class="headerlink" title="第一步 初始化"></a>第一步 初始化</h2><p>就按上图的格式进行初始化棋盘，注意棋盘的方向与数组下标，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">begining</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Blue</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">5</span>,mapp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">4</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">6</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">8</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">3</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">6</span>,mapp[<span class="number">3</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">4</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Red</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">5</span>,mapp[<span class="number">10</span>][<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">4</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">6</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">8</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">8</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">6</span>,mapp[<span class="number">8</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">7</span>;mapp[<span class="number">7</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我调换了红蓝双方的顺序，所以就不用翻转棋盘。</p><h2 id="第二步-基础操作函数："><a href="#第二步-基础操作函数：" class="headerlink" title="第二步 基础操作函数："></a>第二步 基础操作函数：</h2><h3 id="①attack-移动-x2F-攻击"><a href="#①attack-移动-x2F-攻击" class="headerlink" title="①attack 移动&#x2F;攻击"></a>①attack 移动&#x2F;攻击</h3><p>因为移动也是一种特殊的攻击，所以也可以把移动归入攻击一栏,通过from，to参数，考虑攻击前后的敌我关系，具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">attack</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">mapp[x2][y2][from]=mapp[x1][y1][from];</span><br><span class="line">mapp[x1][y1][from]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(to!=<span class="number">-1</span>)mapp[x2][y2][to]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②getgroup-分组"><a href="#②getgroup-分组" class="headerlink" title="②getgroup 分组"></a>②getgroup 分组</h3><p>对于一个坐标的棋子，我们肯定要知道它属于哪一方，自然要写一个函数来获取分组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getgroup</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x][y][<span class="number">0</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mapp[x][y][<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③getcaptain-获取主帅位置"><a href="#③getcaptain-获取主帅位置" class="headerlink" title="③getcaptain 获取主帅位置"></a>③getcaptain 获取主帅位置</h3><p>这一函数将在最后判断将军时用到。比较好理解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node getcaptain(int gr)&#123;</span><br><span class="line">Node t;</span><br><span class="line">for(int i=1;i&lt;=10;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=9;j++)&#123;</span><br><span class="line">if(mapp[i][j][gr]==1)&#123;</span><br><span class="line">t.x=i,t.y=j;</span><br><span class="line">return t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步-判断每个棋子移动的合法性"><a href="#第三步-判断每个棋子移动的合法性" class="headerlink" title="第三步 判断每个棋子移动的合法性"></a>第三步 判断每个棋子移动的合法性</h2><p>这是整道题的重中之重，这里将一一讲解：</p><h3 id="①captain-将的移动"><a href="#①captain-将的移动" class="headerlink" title="①captain 将的移动"></a>①captain 将的移动</h3><p>这是最为简单的移动之一，只要求移动前后的坐标差即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">captain</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②guard-士的移动"><a href="#②guard-士的移动" class="headerlink" title="②guard 士的移动"></a>②guard 士的移动</h3><p>这个移动与将差不多，同样求坐标差</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">guard</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③elephant-象的移动"><a href="#③elephant-象的移动" class="headerlink" title="③elephant 象的移动"></a>③elephant 象的移动</h3><p>这个移动就有点复杂，注意要判断是否移动受阻，可以单独开一个数组判断障碍，这个思路就有点像大家初学BFS的时候模拟移动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">elephant</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,aimy[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,&#125;,sty[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④horse-马的移动"><a href="#④horse-马的移动" class="headerlink" title="④horse 马的移动"></a>④horse 马的移动</h3><p>与象差不多，只要注意马的移动的x,y轴要一一对应，而障碍位置就是马的上下左右4个点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">horse</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑤car-车的移动"><a href="#⑤car-车的移动" class="headerlink" title="⑤car 车的移动"></a>⑤car 车的移动</h3><p>车的移动相对简单，只要一重循环模拟即可。注意一点：要先判断两点时候同行或者同列，否则模拟是无意义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">car</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1!=x2&amp;&amp;y1!=y2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(x1==x2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(y1,y2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(y1,y2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x1][i][<span class="number">0</span>]||mapp[x1][i][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y1==y2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(x1,x2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(x1,x2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][y1][<span class="number">0</span>]||mapp[i][y1][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑥duck-鸭的移动"><a href="#⑥duck-鸭的移动" class="headerlink" title="⑥duck 鸭的移动"></a>⑥duck 鸭的移动</h3><p>鸭这个棋子是所有棋子中最难模拟的，但仔细分析，可以发现，鸭的障碍就是马对应方向的障碍与立足点，所以开2个数组去判断鸭的两层障碍即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">duck</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-3</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> subx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,suby[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="type">int</span> tttx=x1+subx[i],ttty=y1+suby[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑦soldier-兵的移动"><a href="#⑦soldier-兵的移动" class="headerlink" title="⑦soldier 兵的移动"></a>⑦soldier 兵的移动</h3><p>仔细观察，不难发现，兵的移动就是将的移动加上士的移动。所以直接调用上面的函数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soldier</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三步-移动操作"><a href="#第三步-移动操作" class="headerlink" title="第三步 移动操作"></a>第三步 移动操作</h2><p>有了之前的几个函数做铺垫，这个操作就好写很多，先判断是否符合题目中要求，比如同方，起始点无己方棋子等等，然后一一判断是哪种棋子，调用对应的函数即可。如果合法，那么就移动&#x2F;对敌方棋子攻击，调用attack函数，否则输出无解，注意一点，在移动棋子前要先输出前两个信息，即移动的棋子和被攻击的棋子，因为在移动后信息会被改变。 最后输出后两个信息，在下文会讲到。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="comment">//nowgame();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(from!=roun)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//check the size</span></span><br><span class="line"><span class="keyword">if</span>(x1&lt;<span class="number">1</span>||x2&lt;<span class="number">1</span>||x1&gt;<span class="number">10</span>||x2&gt;<span class="number">10</span>||y1&lt;<span class="number">1</span>||y2&lt;<span class="number">1</span>||y1&gt;<span class="number">9</span>||y2&gt;<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the gruops</span></span><br><span class="line"><span class="keyword">if</span>(from==to)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the from</span></span><br><span class="line"><span class="keyword">if</span>(from==<span class="number">-1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if the game is over</span></span><br><span class="line"><span class="keyword">if</span>(flg==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//captain</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//guard</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elephant</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//horse</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//car</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">6</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">7</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(x1,y1,x2,y2,from,to))&#123; </span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四步-判断将军"><a href="#第四步-判断将军" class="headerlink" title="第四步 判断将军"></a>第四步 判断将军</h2><p>将军这个问题看似很难解决，其实换一种思路即可，假设每个敌方棋子都可以将军，然后调用之前的函数，判断假设是否成立，如果成立，说明存在将军，否则则不存在将军。</p><p>这样一来，代码就非常好写了：遍历每个点，对于有敌方棋子的点，就做出假设，然后判断假设。并且这里要用到之前的getcaptain函数来获取两方将的位置。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cankill</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node blue,red;</span><br><span class="line">blue=<span class="built_in">getcaptain</span>(<span class="number">0</span>),red=<span class="built_in">getcaptain</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五步-判断游戏是否结束"><a href="#第五步-判断游戏是否结束" class="headerlink" title="第五步 判断游戏是否结束"></a>第五步 判断游戏是否结束</h2><p>这个问题非常好解决，跑一遍二重循环，统计将的个数，如果小于2，游戏一定结束，注意游戏结束后要设置一个flg，使对接下来命令的处理都是无解。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isend</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][k]==<span class="number">1</span>)t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">2</span>)&#123;</span><br><span class="line">flg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六步-输出"><a href="#第六步-输出" class="headerlink" title="第六步 输出"></a>第六步 输出</h2><p>因为在move函数中已经将前两个信息输出，所以这里只要输出后两个信息即可，直接调用上面的函数，同时在输出的时候更新当前应当走棋的阵营。 对于不合法的调用，输出无解即可。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> M_C,<span class="type">int</span> M_G,<span class="type">int</span> K_C,<span class="type">int</span> K_G,<span class="type">int</span> canmove)</span></span>&#123;</span><br><span class="line"><span class="comment">//canmove?</span></span><br><span class="line"><span class="keyword">if</span>(canmove==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">roun=<span class="number">1</span>-roun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//End?</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isend</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cankill</span>())cout&lt;&lt;<span class="string">&quot;yes;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no;&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tip：主程序中对于每条指令，调用move函数即可。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>献上完整代码，10K,396行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//begining words</span></span><br><span class="line"><span class="type">int</span> Q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> mapp[<span class="number">20</span>][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line">string name[<span class="number">10</span>]=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;captain&quot;</span>,<span class="string">&quot;guard&quot;</span>,<span class="string">&quot;elephant&quot;</span>,<span class="string">&quot;horse&quot;</span>,<span class="string">&quot;car&quot;</span>,<span class="string">&quot;duck&quot;</span>,<span class="string">&quot;soldier&quot;</span>&#125;;</span><br><span class="line">string group[<span class="number">3</span>]=&#123;<span class="string">&quot;red&quot;</span>,<span class="string">&quot;blue&quot;</span>&#125;;</span><br><span class="line"><span class="type">bool</span> flg=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> roun=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">begining</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Blue</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">5</span>,mapp[<span class="number">1</span>][<span class="number">2</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">4</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">1</span>][<span class="number">6</span>][<span class="number">0</span>]=<span class="number">2</span>,mapp[<span class="number">1</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">3</span>,mapp[<span class="number">1</span>][<span class="number">8</span>][<span class="number">0</span>]=<span class="number">4</span>,mapp[<span class="number">1</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">3</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">6</span>,mapp[<span class="number">3</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">4</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">3</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">5</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">7</span>][<span class="number">0</span>]=<span class="number">7</span>,mapp[<span class="number">4</span>][<span class="number">9</span>][<span class="number">0</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Red</span></span><br><span class="line"><span class="comment">//underline character</span></span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">5</span>,mapp[<span class="number">10</span>][<span class="number">2</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">4</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">mapp[<span class="number">10</span>][<span class="number">6</span>][<span class="number">1</span>]=<span class="number">2</span>,mapp[<span class="number">10</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">3</span>,mapp[<span class="number">10</span>][<span class="number">8</span>][<span class="number">1</span>]=<span class="number">4</span>,mapp[<span class="number">10</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line">mapp[<span class="number">8</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">6</span>,mapp[<span class="number">8</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">6</span>;</span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line">mapp[<span class="number">7</span>][<span class="number">1</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">3</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">5</span>][<span class="number">1</span>]=<span class="number">7</span>,mapp[<span class="number">7</span>][<span class="number">7</span>][<span class="number">1</span>]=<span class="number">7</span>;mapp[<span class="number">7</span>][<span class="number">9</span>][<span class="number">1</span>]=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">attack</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line">mapp[x2][y2][from]=mapp[x1][y1][from];</span><br><span class="line">mapp[x1][y1][from]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(to!=<span class="number">-1</span>)mapp[x2][y2][to]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getgroup</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x][y][<span class="number">0</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(mapp[x][y][<span class="number">1</span>])<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">getcaptain</span><span class="params">(<span class="type">int</span> gr)</span></span>&#123;</span><br><span class="line">Node t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][gr]==<span class="number">1</span>)&#123;</span><br><span class="line">t.x=i,t.y=j;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">captain</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tx==<span class="number">0</span>&amp;&amp;ty==<span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">guard</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> tx=<span class="built_in">abs</span>(x1-x2),ty=<span class="built_in">abs</span>(y1-y2);</span><br><span class="line"><span class="keyword">if</span>(tx==<span class="number">1</span>&amp;&amp;ty==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">elephant</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,aimy[<span class="number">4</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>,&#125;,sty[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">horse</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">car</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x1!=x2&amp;&amp;y1!=y2)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(x1==x2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(y1,y2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(y1,y2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[x1][i][<span class="number">0</span>]||mapp[x1][i][<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(y1==y2)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(x1,x2)+<span class="number">1</span>;i&lt;=<span class="built_in">max</span>(x1,x2)<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][y1][<span class="number">0</span>]||mapp[i][y1][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">duck</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> aimx[<span class="number">8</span>]=&#123;<span class="number">-3</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>&#125;,aimy[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-3</span>,<span class="number">-3</span>&#125;;</span><br><span class="line"><span class="type">int</span> stx[<span class="number">8</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,sty[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-2</span>,<span class="number">-2</span>&#125;;</span><br><span class="line"><span class="type">int</span> subx[<span class="number">8</span>]=&#123;<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,suby[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> tx=x1+aimx[i],ty=y1+aimy[i];</span><br><span class="line"><span class="keyword">if</span>(tx==x2&amp;&amp;ty==y2)&#123;</span><br><span class="line"><span class="type">int</span> ttx=x1+stx[i],tty=y1+sty[i];</span><br><span class="line"><span class="type">int</span> tttx=x1+subx[i],ttty=y1+suby[i];</span><br><span class="line"><span class="keyword">if</span>(mapp[ttx][tty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[ttx][tty][<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">0</span>]==<span class="number">0</span>&amp;&amp;mapp[tttx][ttty][<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">soldier</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cankill</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node blue,red;</span><br><span class="line">blue=<span class="built_in">getcaptain</span>(<span class="number">0</span>),red=<span class="built_in">getcaptain</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">0</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,red.x,red.y,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">5</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][<span class="number">1</span>]==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(i,j,blue.x,blue.y,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isend</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mapp[i][j][k]==<span class="number">1</span>)t++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">2</span>)&#123;</span><br><span class="line">flg=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> M_C,<span class="type">int</span> M_G,<span class="type">int</span> K_C,<span class="type">int</span> K_G,<span class="type">int</span> canmove)</span></span>&#123;</span><br><span class="line"><span class="comment">//canmove?</span></span><br><span class="line"><span class="keyword">if</span>(canmove==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">roun=<span class="number">1</span>-roun;</span><br><span class="line"></span><br><span class="line"><span class="comment">//End?</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isend</span>())&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no;yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">cankill</span>())cout&lt;&lt;<span class="string">&quot;yes;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;no;&quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> from,<span class="type">int</span> to)</span></span>&#123;</span><br><span class="line"><span class="comment">//nowgame();</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(from!=roun)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//check the size</span></span><br><span class="line"><span class="keyword">if</span>(x1&lt;<span class="number">1</span>||x2&lt;<span class="number">1</span>||x1&gt;<span class="number">10</span>||x2&gt;<span class="number">10</span>||y1&lt;<span class="number">1</span>||y2&lt;<span class="number">1</span>||y1&gt;<span class="number">9</span>||y2&gt;<span class="number">9</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the gruops</span></span><br><span class="line"><span class="keyword">if</span>(from==to)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check the from</span></span><br><span class="line"><span class="keyword">if</span>(from==<span class="number">-1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//check if the game is over</span></span><br><span class="line"><span class="keyword">if</span>(flg==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Invalid command&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//captain</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">captain</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//guard</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">guard</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//elephant</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">elephant</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//horse</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">horse</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//car</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">car</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//duck</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">6</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">duck</span>(x1,y1,x2,y2,from,to))&#123;</span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//soldier</span></span><br><span class="line"><span class="keyword">if</span>(mapp[x1][y1][from]==<span class="number">7</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">soldier</span>(x1,y1,x2,y2,from,to))&#123; </span><br><span class="line"><span class="type">int</span> ta=mapp[x1][y1][from];</span><br><span class="line"><span class="type">int</span> tb=mapp[x2][y2][to];</span><br><span class="line">cout&lt;&lt;group[from]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[ta]&lt;&lt;<span class="string">&#x27;;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(to==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;NA;&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;group[to]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;name[tb]&lt;&lt;<span class="string">&#x27;;&#x27;</span>; </span><br><span class="line"><span class="built_in">attack</span>(x1,y1,x2,y2,from,to);</span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">print</span>(mapp[x1][y1][from],from,mapp[x2][y2][to],to,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">begining</span>();</span><br><span class="line">cin&gt;&gt;Q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">x1++,y1++,x2++,y2++;</span><br><span class="line"><span class="built_in">move</span>(x1,y1,x2,y2,<span class="built_in">getgroup</span>(x1,y1),<span class="built_in">getgroup</span>(x2,y2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一步-初始化&quot;&gt;&lt;a href=&quot;#第一步-初始化&quot; class=&quot;headerlink&quot; title=&quot;第一步 初始化&quot;&gt;&lt;/a&gt;第一步 初始化&lt;/h2&gt;&lt;p&gt;就按上图的格式进行初始化棋盘，注意棋盘的方向与数组下标，代码如下：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="竞赛解法" scheme="https://q.billma.top/categories/%E7%AB%9E%E8%B5%9B%E8%A7%A3%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>2021南航苏州附中第45届校运会</title>
    <link href="https://q.billma.top/2021/10/01/21sportsmeet/"/>
    <id>https://q.billma.top/2021/10/01/21sportsmeet/</id>
    <published>2021-10-01T10:51:06.000Z</published>
    <updated>2021-10-05T03:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=463274950&bvid=BV1GL411s7AL&cid=417630302&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>原地址：<a href="https://www.bilibili.com/video/BV1GL411s7AL?share_source=copy_web">ClickHere</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=463274950&amp;bvid=BV1GL411s7AL&amp;cid=417630302&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;</summary>
      
    
    
    
    <category term="南航苏州附中校园活动" scheme="https://q.billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>南航苏州附中建党百年朗诵活动</title>
    <link href="https://q.billma.top/2021/09/12/2109poemsay/"/>
    <id>https://q.billma.top/2021/09/12/2109poemsay/</id>
    <published>2021-09-12T10:51:37.000Z</published>
    <updated>2021-10-04T10:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-十人集体诗歌朗诵"><a href="#1-十人集体诗歌朗诵" class="headerlink" title="1.十人集体诗歌朗诵"></a>1.十人集体诗歌朗诵</h2><p>感谢以下参与人员参与录制：</p><p>汤骏懿   姚远  顾天欣 崔可欣 曹艺舟 祝中翔</p><p>杨海佳   沈思遥 王韬越 张翌晨</p><p>导演：马泊宁 姚远</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组：何昊   金弈  蒯翔   顾俊贤   陈星宇</p><h3 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=717999103&bvid=BV1iQ4y1y74b&cid=405971667&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址"><a href="#三连地址" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV1iQ4y1y74b?share_source=copy_web">点击这里</a></p><h2 id="2-陈星宇讲故事"><a href="#2-陈星宇讲故事" class="headerlink" title="2.陈星宇讲故事"></a>2.陈星宇讲故事</h2><p>主讲：陈星宇</p><p>导演：马泊宁</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组： 张祉珺</p><h3 id="视频播放-1"><a href="#视频播放-1" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=590416676&bvid=BV12q4y1Z7t2&cid=405973727&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址-1"><a href="#三连地址-1" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV12q4y1Z7t2?share_source=copy_web">点击这里</a></p><h2 id="3-张祉珺讲故事"><a href="#3-张祉珺讲故事" class="headerlink" title="3.张祉珺讲故事"></a>3.张祉珺讲故事</h2><p>主讲：张祉珺</p><p>导演：马泊宁</p><p>拍摄+后期剪辑：马泊宁 陈星宇</p><p>特别感谢后勤小组： 陈星宇</p><h3 id="视频播放-2"><a href="#视频播放-2" class="headerlink" title="视频播放"></a>视频播放</h3><iframe src="//player.bilibili.com/player.html?aid=420461484&bvid=BV1y3411q7Rx&cid=406000152&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h3 id="三连地址-2"><a href="#三连地址-2" class="headerlink" title="三连地址"></a>三连地址</h3><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV12q4y1Z7t2?share_source=copy_web">点击这里</a></p><h2 id="4-幕后花絮"><a href="#4-幕后花絮" class="headerlink" title="4.幕后花絮"></a>4.幕后花絮</h2><iframe src="//player.bilibili.com/player.html?aid=932957777&bvid=BV1SM4y1G74z&cid=406551816&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p>点击这里给作者给予支持：<a href="https://www.bilibili.com/video/BV1SM4y1G74z?share_source=copy_web">点击这里</a></p><p>感谢观看！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-十人集体诗歌朗诵&quot;&gt;&lt;a href=&quot;#1-十人集体诗歌朗诵&quot; class=&quot;headerlink&quot; title=&quot;1.十人集体诗歌朗诵&quot;&gt;&lt;/a&gt;1.十人集体诗歌朗诵&lt;/h2&gt;&lt;p&gt;感谢以下参与人员参与录制：&lt;/p&gt;
&lt;p&gt;汤骏懿   姚远  顾天欣 崔可欣</summary>
      
    
    
    
    <category term="南航苏州附中校园活动" scheme="https://q.billma.top/categories/%E5%8D%97%E8%88%AA%E8%8B%8F%E5%B7%9E%E9%99%84%E4%B8%AD%E6%A0%A1%E5%9B%AD%E6%B4%BB%E5%8A%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>如何科学上网？</title>
    <link href="https://q.billma.top/2021/09/04/vpn-how-to-open/"/>
    <id>https://q.billma.top/2021/09/04/vpn-how-to-open/</id>
    <published>2021-09-04T12:32:35.000Z</published>
    <updated>2021-09-04T13:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。</p><h2 id="1-Windows"><a href="#1-Windows" class="headerlink" title="1.Windows"></a>1.Windows</h2><h4 id="1-安装-Microsoft-edge"><a href="#1-安装-Microsoft-edge" class="headerlink" title="1.安装 Microsoft edge"></a>1.安装 Microsoft edge</h4><p>其实理论上Google Chrome更加适合，但是你想接下来的操作本身需要科学上网才能访问Google play，所以在这里使用Microsoft edge。</p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win7-92.0.902.84.exe">Windows7点这里下载</a></p><p><a href="https://dl.softmgr.qq.com/original/Browser/MicrosoftEdgeSetup-win10-92.0.902.84.exe">Windows10点这里下载</a></p><h4 id="2-安装扩展"><a href="#2-安装扩展" class="headerlink" title="2.安装扩展"></a>2.安装扩展</h4><p>打开edge，<a href="https://microsoftedge.microsoft.com/addons/detail/setupvpn-lifetime-free-/okhjkpgblgdjappgfgakbcecdblgffcl?hl=zh-CN">打开这个网页</a>,点击安装即可。</p><h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h4><p>点开这个科学上网工具，选择汉语，会跳出一个输入邀请码的东西，不要管他，下面有一个create new account，点击，然后三个协议全选择，跳出一个页面，选择美国即可。</p><h2 id="2-iOS-iphone-or-ipad"><a href="#2-iOS-iphone-or-ipad" class="headerlink" title="2.iOS(iphone or ipad)"></a>2.iOS(iphone or ipad)</h2><h4 id="1-获取Apple-ID"><a href="#1-获取Apple-ID" class="headerlink" title="1.获取Apple ID"></a>1.获取Apple ID</h4><p>由于上述国家部门的要求，Apple Inc中国区下架了所有科学上网工具。所以，现在手机上<a href="apple.com">点击这里</a>注册<strong>一个新的</strong>Apple ID。</p><p>注意，在注册时会让你选择国家与地区，选择美国即可。</p><h4 id="2-登录"><a href="#2-登录" class="headerlink" title="2.登录"></a>2.登录</h4><p>随后，点开App Store，登出后登陆你新注册的Apple ID，随后自动跳转到美国区，搜索V P N 3 6 0即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;相信很多同学都想科学上网，但是由于工 信 部的限制，很少有人能真正科学上网。我今天就介绍几个我长期摸索出来的科学上网工具。&lt;/p&gt;
&lt;h2 id=&quot;1-Windows&quot;&gt;&lt;a href=&quot;#1-Windows&quot; class=&quot;headerlink&quot; title=&quot;1.Win</summary>
      
    
    
    
    <category term="日常经验" scheme="https://q.billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
  <entry>
    <title>今日编程发现--缩进问题</title>
    <link href="https://q.billma.top/2021/08/29/cpp-if-else-question-1/"/>
    <id>https://q.billma.top/2021/08/29/cpp-if-else-question-1/</id>
    <published>2021-08-29T08:11:52.000Z</published>
    <updated>2021-08-29T08:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天偶然看到一段代码是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(...)</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        ...</span><br><span class="line">  <span class="keyword">else</span> ...</span><br></pre></td></tr></table></figure><p>那么问题来了，这么缩进这个else跟的是谁呢？</p><p>其实根据C++原则，else跟的是离他更近的那个if。但是，如果别欣赏这段代码的时候，那可真的难为人家了。</p><p>所以，严格按照语法编代码，保持KISS(Keep it simple,stupid)是最基本的原则。不要写容易混淆的代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天偶然看到一段代码是这么写的：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GitHub下载速度太慢怎么办？</title>
    <link href="https://q.billma.top/2021/08/29/github-speed-up-download/"/>
    <id>https://q.billma.top/2021/08/29/github-speed-up-download/</id>
    <published>2021-08-29T07:17:38.000Z</published>
    <updated>2021-09-04T13:42:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：<a href="billmarepo.github.io">billmarepo.github.io</a>）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么，在下载本站资源时遇到GitHub下载太慢该如何处置？</p><h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1.复制"></a>1.复制</h2><p>找到下载的资源，右击选择：复制目标链接（反正就这个意思，不同浏览器显示不同）。</p><h2 id="2-GitHub文件加速"><a href="#2-GitHub文件加速" class="headerlink" title="2.GitHub文件加速"></a>2.GitHub文件加速</h2><p>利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.<br><a href="https://gh.api.99988866.xyz/">https://gh.api.99988866.xyz</a><br><a href="https://ghproxy.com/">https://ghproxy.com/</a><br>以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。</p><h2 id="3-Github-加速下载"><a href="#3-Github-加速下载" class="headerlink" title="3.Github 加速下载"></a>3.Github 加速下载</h2><p>将你复制的链接到以下网址就可以加速下载了！</p><p>地址：<a href="http://toolwa.com/github/">http://toolwa.com/github/</a></p><h2 id="4-其他友情链接"><a href="#4-其他友情链接" class="headerlink" title="4.其他友情链接"></a>4.其他友情链接</h2><h3 id="官网镜像（可以用来clone-push等-但是不能登录）"><a href="#官网镜像（可以用来clone-push等-但是不能登录）" class="headerlink" title="官网镜像（可以用来clone push等,但是不能登录）"></a>官网镜像（可以用来clone push等,但是不能登录）</h3><p><a href="https://github.com.cnpmjs.org/">https://github.com.cnpmjs.org/</a></p><p><a href="https://hub.fastgit.org/">https://hub.fastgit.org/</a> <strong>（速度最快）</strong></p><p><a href="https://github.wuyanzheshui.workers.dev/">https://github.wuyanzheshui.workers.dev/</a></p><h3 id="API镜像（用来api操作）"><a href="#API镜像（用来api操作）" class="headerlink" title="API镜像（用来api操作）"></a>API镜像（用来api操作）</h3><p><a href="https://api.git.sdut.me/">https://api.git.sdut.me/</a></p><p><a href="https://v2.kkpp.cc/">https://v2.kkpp.cc/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：&lt;a href=&quot;billmarepo.github.io&quot;&gt;billmarepo.github.io&lt;/a&gt;）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么</summary>
      
    
    
    
    <category term="日常经验" scheme="https://q.billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="github" scheme="https://q.billma.top/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>python之matplotlib详细教程</title>
    <link href="https://q.billma.top/2021/08/26/python-matplotlib/"/>
    <id>https://q.billma.top/2021/08/26/python-matplotlib/</id>
    <published>2021-08-26T11:44:55.000Z</published>
    <updated>2021-08-29T07:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>前提：你已经安装了python并且在安装时勾选了Add Python to PATH</strong></p><p>打开cmd，输入如下指令：（不要复制粘贴）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>安装完后打开python，就可以开始了！</p><h1 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h1 id="1请求一个新的figure对象"><a href="#1请求一个新的figure对象" class="headerlink" title="1请求一个新的figure对象"></a>1请求一个新的figure对象</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br></pre></td></tr></table></figure><h2 id="1-2Axes"><a href="#1-2Axes" class="headerlink" title="1.2Axes"></a>1.2Axes</h2><p>在拥有Figure对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加Axes。也可以理解成为真正可以作画的纸。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(xlim=[<span class="number">0.5</span>, <span class="number">4.5</span>], ylim=[-<span class="number">2</span>, <span class="number">8</span>], title=<span class="string">&#x27;An Example Axes&#x27;</span>,</span><br><span class="line">       ylabel=<span class="string">&#x27;Y-Axis&#x27;</span>, xlabel=<span class="string">&#x27;X-Axis&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置）</p><p>对于上面的fig.add_subplot(111)就是添加Axes的，参数的解释的在画板的第1行第1列的第一个位置生成一个Axes对象来准备作画。也可以通过fig.add_subplot(2, 2, 1)的方式生成Axes，前面两个参数确定了面板的划分，例如 2， 2会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个Axes。如下面的例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">224</span>)</span><br></pre></td></tr></table></figure><h2 id="1-3-Multiple-Axes"><a href="#1-3-Multiple-Axes" class="headerlink" title="1.3 Multiple Axes"></a>1.3 Multiple Axes</h2><p>可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Upper Right&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Left&#x27;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].<span class="built_in">set</span>(title=<span class="string">&#x27;Lower Right&#x27;</span>)</span><br></pre></td></tr></table></figure><p>fig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。</p><h2 id="1-4-Axes-Vs-pyplot"><a href="#1-4-Axes-Vs-pyplot" class="headerlink" title="1.4 Axes Vs .pyplot"></a>1.4 Axes Vs .pyplot</h2><p>相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], color=<span class="string">&#x27;lightblue&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line">plt.xlim(<span class="number">0.5</span>, <span class="number">4.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="2-基本绘图2D"><a href="#2-基本绘图2D" class="headerlink" title="2. 基本绘图2D"></a>2. 基本绘图2D</h1><h2 id="2-1-线"><a href="#2-1-线" class="headerlink" title="2.1 线"></a>2.1 线</h2><p>plot()函数画出一系列的点，并且用线将它们连接起来。看下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, np.pi)</span><br><span class="line">y_sin = np.sin(x)</span><br><span class="line">y_cos = np.cos(x)</span><br><span class="line"></span><br><span class="line">ax1.plot(x, y_sin)</span><br><span class="line">ax2.plot(x, y_sin, <span class="string">&#x27;go--&#x27;</span>, linewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line">ax3.plot(x, y_cos, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>, linestyle=<span class="string">&#x27;dashed&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。</p><p>另外，我们可以通过关键字参数的方式绘图，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">200</span>)</span><br><span class="line">data_obj = &#123;<span class="string">&#x27;x&#x27;</span>: x,</span><br><span class="line">            <span class="string">&#x27;y1&#x27;</span>: <span class="number">2</span> * x + <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;y2&#x27;</span>: <span class="number">3</span> * x + <span class="number">1.2</span>,</span><br><span class="line">            <span class="string">&#x27;mean&#x27;</span>: <span class="number">0.5</span> * x * np.cos(<span class="number">2</span>*x) + <span class="number">2.5</span> * x + <span class="number">1.1</span>&#125;</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment">#填充两条线之间的颜色</span></span><br><span class="line">ax.fill_between(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y1&#x27;</span>, <span class="string">&#x27;y2&#x27;</span>, color=<span class="string">&#x27;yellow&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot the &quot;centerline&quot; with `plot`</span></span><br><span class="line">ax.plot(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;mean&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>, data=data_obj)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。</p><h2 id="2-2-散点图"><a href="#2-2-散点图" class="headerlink" title="2.2 散点图"></a>2.2 散点图</h2><p>只画点，但是不用线连接起来。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">10</span>)</span><br><span class="line">y = np.random.randn(<span class="number">10</span>)</span><br><span class="line">plt.scatter(x, y, color=<span class="string">&#x27;red&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-3-条形图"><a href="#2-3-条形图" class="headerlink" title="2.3 条形图"></a>2.3 条形图</h2><p>条形图分两种，一种是水平的，一种是垂直的，见下例子：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line">x = np.arange(<span class="number">5</span>)</span><br><span class="line">y = np.random.randn(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(ncols=<span class="number">2</span>, figsize=plt.figaspect(<span class="number">1.</span>/<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">vert_bars = axes[<span class="number">0</span>].bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">horiz_bars = axes[<span class="number">1</span>].barh(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment">#在水平或者垂直方向上画线</span></span><br><span class="line">axes[<span class="number">0</span>].axhline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">1</span>].axvline(<span class="number">0</span>, color=<span class="string">&#x27;gray&#x27;</span>, linewidth=<span class="number">2</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">vert_bars = ax.bar(x, y, color=<span class="string">&#x27;lightblue&#x27;</span>, align=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.</span></span><br><span class="line"><span class="keyword">for</span> bar, height <span class="keyword">in</span> <span class="built_in">zip</span>(vert_bars, y):</span><br><span class="line">    <span class="keyword">if</span> height &lt; <span class="number">0</span>:</span><br><span class="line">        bar.<span class="built_in">set</span>(edgecolor=<span class="string">&#x27;darkred&#x27;</span>, color=<span class="string">&#x27;salmon&#x27;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-4-直方图"><a href="#2-4-直方图" class="headerlink" title="2.4 直方图"></a>2.4 直方图</h2><p>直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">n_bins = <span class="number">10</span></span><br><span class="line">x = np.random.randn(<span class="number">1000</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">fig, axes = plt.subplots(nrows=<span class="number">2</span>, ncols=<span class="number">2</span>)</span><br><span class="line">ax0, ax1, ax2, ax3 = axes.flatten()</span><br><span class="line"></span><br><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;tan&#x27;</span>, <span class="string">&#x27;lime&#x27;</span>]</span><br><span class="line">ax0.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;bar&#x27;</span>, color=colors, label=colors)</span><br><span class="line">ax0.legend(prop=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;bars with legend&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.hist(x, n_bins, density=<span class="literal">True</span>, histtype=<span class="string">&#x27;barstacked&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;stacked bar&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.hist(x,  histtype=<span class="string">&#x27;barstacked&#x27;</span>, rwidth=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">ax3.hist(x[:, <span class="number">0</span>], rwidth=<span class="number">0.9</span>)</span><br><span class="line">ax3.set_title(<span class="string">&#x27;different sample sizes&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。</p><h2 id="2-5-饼图"><a href="#2-5-饼图" class="headerlink" title="2.5 饼图"></a>2.5 饼图</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">labels = <span class="string">&#x27;Frogs&#x27;</span>, <span class="string">&#x27;Hogs&#x27;</span>, <span class="string">&#x27;Dogs&#x27;</span>, <span class="string">&#x27;Logs&#x27;</span></span><br><span class="line">sizes = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]</span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)</span></span><br><span class="line"></span><br><span class="line">fig1, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.pie(sizes, labels=labels, autopct=<span class="string">&#x27;%1.1f%%&#x27;</span>, shadow=<span class="literal">True</span>)</span><br><span class="line">ax1.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.pie(sizes, autopct=<span class="string">&#x27;%1.2f%%&#x27;</span>, shadow=<span class="literal">True</span>, startangle=<span class="number">90</span>, explode=explode,</span><br><span class="line">    pctdistance=<span class="number">1.12</span>)</span><br><span class="line">ax2.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">ax2.legend(labels=labels, loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>饼图自动根据数据的百分比画饼.。labels是各个块的标签，如子图一。autopct&#x3D;%1.1f%%表示格式化百分比精确输出，explode，突出某些块，不同的值突出的效果不一样。pctdistance&#x3D;1.12百分比距离圆心的距离，默认是0.6.</p><h2 id="2-6-箱形图"><a href="#2-6-箱形图" class="headerlink" title="2.6 箱形图"></a>2.6 箱形图</h2><p>为了专注于如何画图，省去数据的处理部分。 data 的 shape 为 (n, )， data2 的 shape 为 (n, 3)。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.boxplot(data)</span><br><span class="line">ax2.boxplot(data2, vert=<span class="literal">False</span>) <span class="comment">#控制方向</span></span><br></pre></td></tr></table></figure><p>2.7 泡泡图<br>散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">50</span></span><br><span class="line">x = np.random.rand(N)</span><br><span class="line">y = np.random.rand(N)</span><br><span class="line">colors = np.random.rand(N)</span><br><span class="line">area = (<span class="number">30</span> * np.random.rand(N))**<span class="number">2</span>  <span class="comment"># 0 to 15 point radii</span></span><br><span class="line"></span><br><span class="line">plt.scatter(x, y, s=area, c=colors, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-8-等高线（轮廓图）"><a href="#2-8-等高线（轮廓图）" class="headerlink" title="2.8 等高线（轮廓图）"></a>2.8 等高线（轮廓图）</h2><p>有时候需要描绘边界的时候，就会用到轮廓图，机器学习用的决策边界也常用轮廓图来绘画，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">y = np.arange(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">0.1</span>)</span><br><span class="line">xx, yy = np.meshgrid(x, y, sparse=<span class="literal">True</span>)</span><br><span class="line">z = np.sin(xx**<span class="number">2</span> + yy**<span class="number">2</span>) / (xx**<span class="number">2</span> + yy**<span class="number">2</span>)</span><br><span class="line">ax1.contourf(x, y, z)</span><br><span class="line">ax2.contour(x, y, z)</span><br></pre></td></tr></table></figure><p>上面画了两个一样的轮廓图，contourf会填充轮廓线之间的颜色。数据x, y, z通常是具有相同 shape 的二维矩阵。x, y 可以为一维向量，但是必需有 z.shape &#x3D; (y.n, x.n) ，这里 y.n 和 x.n 分别表示x、y的长度。Z通常表示的是距离X-Y平面的距离，传入X、Y则是控制了绘制等高线的范围。</p><h1 id="3-布局、图例说明、边界等"><a href="#3-布局、图例说明、边界等" class="headerlink" title="3 布局、图例说明、边界等"></a>3 布局、图例说明、边界等</h1><h2 id="3-1区间上下限"><a href="#3-1区间上下限" class="headerlink" title="3.1区间上下限"></a>3.1区间上下限</h2><p>当绘画完成后，会发现X、Y轴的区间是会自动调整的，并不是跟我们传入的X、Y轴数据中的最值相同。为了调整区间我们使用下面的方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax.set_xlim([xmin, xmax])   <span class="comment">#设置X轴的区间</span></span><br><span class="line">ax.set_ylim([ymin, ymax])   <span class="comment">#Y轴区间</span></span><br><span class="line">ax.axis([xmin, xmax, ymin, ymax])   <span class="comment">#X、Y轴区间</span></span><br><span class="line">ax.set_ylim(bottom=-<span class="number">10</span>)     <span class="comment">#Y轴下限</span></span><br><span class="line">ax.set_xlim(right=<span class="number">25</span>)       <span class="comment">#X轴上限</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">ax1.plot(x, y)</span><br><span class="line">ax2.plot(x, y)</span><br><span class="line">ax2.set_xlim([-<span class="number">1</span>, <span class="number">6</span>])</span><br><span class="line">ax2.set_ylim([-<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>可以看出修改了区间之后影响了图片显示的效果。</p><h2 id="3-2-图例说明"><a href="#3-2-图例说明" class="headerlink" title="3.2 图例说明"></a>3.2 图例说明</h2><p>我们如果我们在一个Axes上做多次绘画，那么可能出现分不清哪条线或点所代表的意思。这个时间添加图例说明，就可以解决这个问题了，见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">30</span>], label=<span class="string">&#x27;Philadelphia&#x27;</span>)</span><br><span class="line">ax.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">30</span>, <span class="number">23</span>, <span class="number">13</span>, <span class="number">4</span>], label=<span class="string">&#x27;Boston&#x27;</span>)</span><br><span class="line">ax.scatter([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">20</span>, <span class="number">10</span>, <span class="number">30</span>, <span class="number">15</span>], label=<span class="string">&#x27;Point&#x27;</span>)</span><br><span class="line">ax.<span class="built_in">set</span>(ylabel=<span class="string">&#x27;Temperature (deg C)&#x27;</span>, xlabel=<span class="string">&#x27;Time&#x27;</span>, title=<span class="string">&#x27;A tale of two cities&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在绘图时传入 label 参数，并最后调用ax.legend()显示体力说明，对于 legend 还是传入参数，控制图例说明显示的位置：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Location StringLocation Code</span><br><span class="line">‘best’<span class="number">0</span></span><br><span class="line">‘upper right’<span class="number">1</span></span><br><span class="line">‘upper left’<span class="number">2</span></span><br><span class="line">‘lower left’<span class="number">3</span></span><br><span class="line">‘lower right’<span class="number">4</span></span><br><span class="line">‘right’<span class="number">5</span></span><br><span class="line">‘center left’<span class="number">6</span></span><br><span class="line">‘center right’<span class="number">7</span></span><br><span class="line">‘lower center’<span class="number">8</span></span><br><span class="line">‘upper center’<span class="number">9</span></span><br><span class="line">‘center’<span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="3-3-区间分段"><a href="#3-3-区间分段" class="headerlink" title="3.3 区间分段"></a>3.3 区间分段</h2><p>默认情况下，绘图结束之后，Axes 会自动的控制区间的分段。见下例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data = [(<span class="string">&#x27;apples&#x27;</span>, <span class="number">2</span>), (<span class="string">&#x27;oranges&#x27;</span>, <span class="number">3</span>), (<span class="string">&#x27;peaches&#x27;</span>, <span class="number">1</span>)]</span><br><span class="line">fruit, value = <span class="built_in">zip</span>(*data)</span><br><span class="line"></span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">2</span>)</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(fruit))</span><br><span class="line">ax1.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">ax2.bar(x, value, align=<span class="string">&#x27;center&#x27;</span>, color=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.<span class="built_in">set</span>(xticks=x, xticklabels=fruit)</span><br><span class="line"></span><br><span class="line"><span class="comment">#ax.tick_params(axis=&#x27;y&#x27;, direction=&#x27;inout&#x27;, length=10) #修改 ticks 的方向以及长度</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>上面不仅修改了X轴的区间段，并且修改了显示的信息为文本。</p><h2 id="3-4-布局"><a href="#3-4-布局" class="headerlink" title="3.4 布局"></a>3.4 布局</h2><p>当我们绘画多个子图时，就会有一些美观的问题存在，例如子图之间的间隔，子图与画板的外边间距以及子图的内边距，下面说明这个问题：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, figsize=(<span class="number">9</span>, <span class="number">9</span>))</span><br><span class="line">fig.subplots_adjust(wspace=<span class="number">0.5</span>, hspace=<span class="number">0.3</span>,</span><br><span class="line">                    left=<span class="number">0.125</span>, right=<span class="number">0.9</span>,</span><br><span class="line">                    top=<span class="number">0.9</span>,    bottom=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#fig.tight_layout() #自动调整布局，使标题之间不重叠</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>通过fig.subplots_adjust()我们修改了子图水平之间的间隔wspace&#x3D;0.5，垂直方向上的间距hspace&#x3D;0.3，左边距left&#x3D;0.125 等等，这里数值都是百分比的。以 [0, 1] 为区间，选择left、right、bottom、top 注意 top 和 right 是 0.9 表示上、右边距为百分之10。不确定如果调整的时候，fig.tight_layout()是一个很好的选择。之前说到了内边距，内边距是子图的，也就是 Axes 对象，所以这样使用 ax.margins(x&#x3D;0.1, y&#x3D;0.1)，当值传入一个值时，表示同时修改水平和垂直方向的内边距。</p><p>调整使他们使用一样的X、Y轴：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">ax2.plot([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="3-5-轴相关"><a href="#3-5-轴相关" class="headerlink" title="3.5 轴相关"></a>3.5 轴相关</h2><p>改变边界的位置，去掉四周的边框：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot([-<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [-<span class="number">10</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">5</span>])</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)     <span class="comment">#顶边界不可见</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)  <span class="comment"># ticks 的位置为下方，分上下的。</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_visible(<span class="literal">False</span>)   <span class="comment">#右边界不可见</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;outward&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界离 Axes 10 个距离</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;outward&#x27;, 10))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;data&quot;</span></span><br><span class="line"><span class="comment"># 移动左、下边界到 (0, 0) 处相交</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &quot;axes&quot;</span></span><br><span class="line"><span class="comment"># 移动边界，按 Axes 的百分比位置</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;, 0.75))</span></span><br><span class="line"><span class="comment">#ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.3))</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;前提：你已经安装了python并且在安装时勾选了Add Python to PATH&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;打开c</summary>
      
    
    
    
    
    <category term="python" scheme="https://q.billma.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>从零开始C++——1</title>
    <link href="https://q.billma.top/2021/08/26/cpp-begin-1/"/>
    <id>https://q.billma.top/2021/08/26/cpp-begin-1/</id>
    <published>2021-08-26T08:23:43.000Z</published>
    <updated>2021-10-01T06:52:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为原创文章，请转载时一定要注明作者：Bill Ma，网址<a href="https://billma.top/">https://billma.top</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This blog is licensed under CC BY-NC-SA 4.0 unless stating additionally.</span><br></pre></td></tr></table></figure><h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><p>看到这篇文章，说明你已经有了这个想法。那么，想要编程，总得要一个软件吧。如果你已经有一定的其他的语言基础，知道了编程软件的基本架构，建议你使用Microsoft的Visual Studio Code。如果你对编程一无所知，你可以使用小白软件Dev C++。</p><p><a href="https://sm.myapp.com/original/Development/Dev-Cpp_5.11_TDM-GCC_4.9.2_Setup.exe">点此下载DevC++</a></p><p><a href="https://dl.softmgr.qq.com/original/Development/VSCodeUserSetup-x64-1.58.2.exe">点此下载MicrosoftVisualStudioCode</a></p><p>本教程就以Dev C++为实例。</p><h2 id="1-启动界面"><a href="#1-启动界面" class="headerlink" title="1.启动界面"></a>1.启动界面</h2><p>启动界面，发现该界面分为四部分。上面是菜单栏和一堆按钮，右侧是一块大空白，左侧是“项目管理，查看类和调试”，下面是调试。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/1.JPG" alt="启动界面"></p><p>接下来，按Ctrl+N，新建一个源代码。</p><p><img src="https://billmarepo.github.io/cpp-begin-1-image/2.JPG"></p><h2 id="2-了解C-基本构造"><a href="#2-了解C-基本构造" class="headerlink" title="2.了解C++基本构造"></a>2.了解C++基本构造</h2><h3 id="a-头文件"><a href="#a-头文件" class="headerlink" title="a.头文件"></a>a.头文件</h3><p>头文件以 <code>#include</code> 开头。你在C++中所用到的所有函数都包含在各种各样的头文件中。比如说，最常见的输出函数printf()就在cstdio头文件中。再比如说，输入输出流cin和cout就在iostream中。如果你懒得记哪个函数在哪个函数库头文件里，你可以偷懒，只写一个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个头文件包含了C++大多数常用头文件。你写了这个就不用再写其它头文件了。但是注意，bits&#x2F;stdc++.h不包含所有头文件。比如说，比较常用的<code>#include&lt;conio.h&gt;</code>和<code>#include &lt;windows.h&gt;</code>就不在其中。</p><h3 id="b-函数"><a href="#b-函数" class="headerlink" title="b.函数"></a>b.函数</h3><p>函数有很多种，现在讲为时过早，日后再议。现在要知道的是主函数。主函数是C++代码的核心部分。C++所有代码都包含在主函数内。在主函数的最后，需要以<code>return 0;</code>为结尾。</p><h3 id="c-变量"><a href="#c-变量" class="headerlink" title="c.变量"></a>c.变量</h3><p>C++提供了许多变量。其中包含</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整形变量(存放整数)</span></span><br><span class="line"><span class="type">int</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型函数</span></span><br><span class="line"><span class="type">float</span><span class="comment">//单精度</span></span><br><span class="line"><span class="type">double</span><span class="comment">//双精度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符/字符串</span></span><br><span class="line"><span class="type">char</span><span class="comment">//单个字符</span></span><br><span class="line">string<span class="comment">//字符串</span></span><br><span class="line"><span class="type">wchar_t</span><span class="comment">//单个宽字符，即非英文或数字</span></span><br><span class="line">wstring<span class="comment">//宽字符串</span></span><br></pre></td></tr></table></figure><p>注意，上图的&#x2F;&#x2F;代表注释，不参与主要运算。</p><p>变量声明方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">string c;</span><br></pre></td></tr></table></figure><p>哦，差点忘了，你想要运行你的程序，只需要按F11或者选择编译即可。</p><h1 id="2-你的第一个程序"><a href="#2-你的第一个程序" class="headerlink" title="2.你的第一个程序"></a>2.你的第一个程序</h1><p>先从一个例子开始：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-标准输入输出"><a href="#1-标准输入输出" class="headerlink" title="1.标准输入输出"></a>1.标准输入输出</h2><figure class="highlight plaintext"><figcaption><span><iostream>```包含了cout,cin,endl等。cout表示输出，cin表示输入，endl是换行符。C++将键盘作为输入设备，屏幕等为输出设备。而且，C++将你输入的和输出的当作一个流，比如说以下两句话是等价的：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C++</span><br><span class="line">cout&lt;&lt;&quot;helloworld!&quot;&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;world!&quot;&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>因为C++是输出流，所以先把hello流出来再把world流出来，和流出来helloworld是一样的。<br>下面是cout和cin的具体用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a,b,c,d</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;<span class="comment">//这里没有endl</span></span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;endl&lt;&lt;d&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输入： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32 44 23 23</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">324423</span><br><span class="line">23</span><br></pre></td></tr></table></figure><p>为什么a和b和c中间没有空格呢？很简单，因为你没有加空格啊。a和b都是数字，没有空格。</p><p>那么，下面代码会输出什么呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="number">12</span>&lt;&lt;<span class="number">34</span>&lt;&lt;<span class="number">56</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;  <span class="number">12</span>  &lt;&lt;  <span class="number">34</span>  &lt;&lt;  <span class="number">56</span>  &lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;12&quot;</span>&lt;&lt;<span class="string">&quot;34&quot;</span>&lt;&lt;<span class="string">&quot;56&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;  12  &quot;</span>&lt;&lt;<span class="string">&quot;  34  &quot;</span>&lt;&lt;<span class="string">&quot;  56  &quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="number">12</span>    <span class="number">34</span>    <span class="number">56</span>  </span><br></pre></td></tr></table></figure><p>有人会问，为什么2也是123456？因为在每两个 &lt;&lt; 中，只能有一个量（变量和常量），你用双引号引起来的叫字符串，只有在变量或者字符串里的才能被输出。</p><h1 id="3-你的第二个程序"><a href="#3-你的第二个程序" class="headerlink" title="3.你的第二个程序"></a>3.你的第二个程序</h1><p>这个程序要稍微复杂一点了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    a=a+<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：1，输出：2</p><p>这个a&#x3D;a+1不是非法语句，而是正确的。这句话翻译成中文就是：a在你原来a的基础上再+1</p><h1 id="4-你的第三个程序"><a href="#4-你的第三个程序" class="headerlink" title="4.你的第三个程序"></a>4.你的第三个程序</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> a=<span class="number">1</span>;a&lt;=<span class="number">7</span>;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">1</span>||a&gt;=<span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;=<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;2&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">5</span>&amp;&amp;a&gt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;3&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;4&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>什么意思呢？首先来看<code>for(int a=1;a&lt;=7;a++)</code>,这句话意思是a从1开始技术</p><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文为原创文章，请转载时一定要注明作者：Bill Ma，网址&lt;a href=&quot;https://billma.top/&quot;&gt;https://billma.top&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    
    <category term="teach，computer，cpp" scheme="https://q.billma.top/tags/teach%EF%BC%8Ccomputer%EF%BC%8Ccpp/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中如何处理错误和异常？</title>
    <link href="https://q.billma.top/2021/08/26/cpp-constructor-exception/"/>
    <id>https://q.billma.top/2021/08/26/cpp-constructor-exception/</id>
    <published>2021-08-26T08:13:08.000Z</published>
    <updated>2021-09-04T13:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的返回值来判断的，一般是返回0、NULL或者-1表示错误，或者直接返回错误代码，具体是哪种方式没有统一的规定，各种API也各有各的偏好。譬如fopen函数，当成功时返回文件指针，失败时返回NULL，而POSIX标准的open函数则在成功时返回0或者正数，失败时返回-1，然后需要再通过全局变量errno来判断具体错误是什么，配套的还有一系列perror、strerror这样的函数。</p><h2 id="2-C-的错误处理方式"><a href="#2-C-的错误处理方式" class="headerlink" title="2.C++的错误处理方式"></a>2.C++的错误处理方式</h2><p>C++号称向下兼容C语言，于是就将C语言通过返回值的错误处理方式也搬了进来。但C++最大的不同是引入了异常机制，可以用throw产生一个异常，并通过try和catch来捕获。于是就混乱了，到底是什么时候使用返回值表示错误，什么时候使用异常呢？首先简单谈论一下异常和返回值的特点。</p><h3 id="异常的优点"><a href="#异常的优点" class="headerlink" title="异常的优点"></a>异常的优点</h3><p>错误信息丰富，便于获得错误现场</p><p>代码相对简短，不需要判断每个函数的返回值</p><h3 id="异常的缺点"><a href="#异常的缺点" class="headerlink" title="异常的缺点"></a>异常的缺点</h3><p>使控制流变得复杂，难以追踪</p><p>开销相对较大</p><h3 id="返回值的优点"><a href="#返回值的优点" class="headerlink" title="返回值的优点"></a>返回值的优点</h3><p>性能开销相对小</p><p>避免定义异常类</p><h3 id="返回值的缺点"><a href="#返回值的缺点" class="headerlink" title="返回值的缺点"></a>返回值的缺点</h3><p>程序员经常「忘记」处理错误返回值</p><p>每个可能产生错误的函数在调用后都需要判断是否有错误</p><p>与「真正的」返回值混用，需要规定一个错误代码（通常是0、-1或NULL）<br>使用异常还是返回值</p><p>我的观点是，用异常来表示真正的、而且不太可能发生的错误。所谓不太可能发生的错误，指的是真正难以预料，但发生了却又不得不单独处理的，譬如内存耗尽、读文件发生故障。而在一个字符串中查找一个子串，如果没有找到显然应该是用一个特殊的返回值（如-1），而不应该抛出一个异常。</p><p>一句话来概况就是不要用异常代替正常的控制流，只有当程序真的「不正常」的时候，才使用异常。反过来说，当程序真正发生错误了，一定要使用异常而不是返回一个错误代码，因为错误代码总是倾向于被忽略。如果要保证一个以返回值来表示错误代码的函数的错误正确地向上传递，需要在每个调用了可能产生错误的函数后面都判断一下是否发生了错误，一旦发生了不可解决的错误，就要终止当前函数（并释放当前函数申请的资源），然后向上传递错误。这样一来错误处理代码会被重复地写好几遍，十分冗杂，譬如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> fd = <span class="built_in">open</span>(<span class="string">&quot;path/to/file&quot;</span>, O_RDONLY);</span><br><span class="line">  <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ERROR_OPEN;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span>* array = <span class="keyword">new</span>[n];</span><br><span class="line">  <span class="type">int</span> err;</span><br><span class="line">  err = <span class="built_in">do_something</span>(fd, array);</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_other_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  err = <span class="built_in">do_more_thing</span>();</span><br><span class="line">  <span class="keyword">if</span> (err != SUCCESS) &#123;</span><br><span class="line">     <span class="keyword">delete</span>[] array;</span><br><span class="line">     <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] array;</span><br><span class="line">  <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对使用异常容易增加函数出口的指控其实是不成立的，因为即使使用返回值，这些出口也是免不了的，除非程序员有意或无意忽略掉，但异常是不可忽略的。如果你认为可以把判断错误的if语句缩写到一行使代码变得「更清晰」，那么我只能说是自欺欺人。</p><p>有些错误几乎总是可以被立即恢复（譬如前面所说的查找一个字符串不存在的子串，甚至都不能说这是一个「错误」），而且返回值本身就传递一定信息，就不需要使用异常了。</p><p>鉴于C++没有统一的ABI，并不建议在模块的接口上使用异常。如果要使用，就要把可能曝露给用户的异常全部声明出来，不要把其他类型的异常丢给用户去处理，尤其是内部状态——模块的使用者通常也不会关心模块内部具体是哪条语句发生错误了。</p><h2 id="3-构造函数中的错误"><a href="#3-构造函数中的错误" class="headerlink" title="3.构造函数中的错误"></a>3.构造函数中的错误</h2><p>有一个相当实际的问题是，如何处理构造函数的错误？我们都知道构造函数是没有返回值的，怎么办呢？通常有三种常见的处理方法，标记错误状态、使用一个额外的initialize函数来初始化，或者直接抛出异常。</p><p>合格的C++程序员都知道C++的析构函数中不应该抛出异常，一旦析构函数中的异常没有被捕获，整个程序都要被中止掉。于是许多人就对在构造函数中抛出异常也产生了对等的恐惧，宁可使用一个额外的初始化函数在里面初始化对象的状态并抛出异常（或者返回错误代码）。这样做违背了对象产生和初始化要在一起的原则，强迫用户记住调用一个额外的初始化函数，一旦没有调用直接使用了其他函数，其行为很可能是未定义的。</p><p>使用初始化函数的惟一好处可能是避免了手动释放资源（释放资源的操作交给析构函数来做），因为C++的一个特点是构造函数抛出异常以后析构函数是不会被调用的，所以如果你在构造函数里面申请了内存或者打开了资源，需要在异常产生时关闭。但想想看其实并不能完全避免，因为有些资源可能是要在可能产生错误的函数调用过后才被申请的，还是无法完全避免手工的释放。</p><p>标记错误状态也是一种常见的形式，譬如STL中的ifstream类，当构造时传入一个无法访问的文件作为参数，它不会返回任何错误，而是标记的内部状态为不可用，用户需要手工通过is_open()函数来判断是否打开成功了。同时它还有good()、fail()两个函数，同时也重载了bool类型转换运算符用于在if语句中判断。标记状态的方法在实践中相当丑陋，因为在使用前总是需要判断它是否「真的创建成功了」。</p><p>最直接的方法还是在构造函数中抛出异常，它并不会向析构函数中抛出异常那样有严重的后果，只是需要注意的是抛出异常以后对象没有被创建成功，析构函数也不会被调用，所以应该自行把申请的资源全部都释放掉。</p><h2 id="4-如何在构造函数中捕获异常"><a href="#4-如何在构造函数中捕获异常" class="headerlink" title="4.如何在构造函数中捕获异常"></a>4.如何在构造函数中捕获异常</h2><p>构造函数与普通函数有一个很不一样特性，就是构造函数可以有初始化列表，例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> val) : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上的代码中A的构造函数的函数体的语句在执行之前会先调用B的构造函数，这时候问题在于，如果B的构造函数抛出了异常，A该如何捕获呢？一个迂回的做法是在A中把B的实例声明为指针，在构造函数和析构函数中分别创建和删除，这样就能捕获到异常了。不过，实际上是有更简单的做法的。下面我要介绍一个C++的很不常见的语法：函数作用域级别的异常捕获。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> val) : <span class="built_in">val_</span>(val * val) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from B&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> val_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;wtf from A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意上面A的构造函数，在参数列表后和初始化列表前增加了try关键字，然后构造函数就被分割为了两部分，前面是初始化，后面是初始化时的错误处理。需要指出的是，catch块里面捕获到的异常不能被忽略，即catch块中必须有一个throw语句重新抛出异常，如果没有，则默认会将原来捕获到的异常重新抛出，这和一般的行为是不同的。例如下面代码运行可以发现A会将捕获到的异常原封不动抛出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> val) <span class="keyword">try</span> : <span class="built_in">b_</span>(val) &#123;</span><br><span class="line">    a_ = val;</span><br><span class="line">  &#125; <span class="built_in">catch</span> (runtime_error&amp; e) &#123;</span><br><span class="line">    cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a_;</span><br><span class="line">  B b_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种语法是C++的标准，而且目前已经被所有的主流C++编译器支持（VS2010、g++ 4.2、clang 3.1），所以几乎不存在兼容性问题，大可放心使用。</p><h2 id="5-其他语言中的错误处理"><a href="#5-其他语言中的错误处理" class="headerlink" title="5.其他语言中的错误处理"></a>5.其他语言中的错误处理</h2><p>Java倾向于大量使用异常，而且还把异常分为了两类分别是检查型异常(Checked Exception)和非检查型异常(Unchecked Exception)，检查型异常就是java.lang.Exception的子类，用于报告需要检查的错误，也就是正常的业务逻辑，错误主要是由用户产生的，方便恢复或给出提示，譬如打开不存在的文件。而非检查型异常则是真正的系统异常，通常由软件缺陷导致，如数组下标越界、错误的类型转换等，这类异常继承于java.lang.RuntimeException或java.lang.Error。</p><p>Python和Java一样也倾向于使用异常，并不一定真的发生故障才抛出异常，譬如字符串转换为整数，如果字符串不合法，Python会抛出一个ValueError异常。甚至Python的迭代器在调用next()时没有更多的结果时会抛出StopIteration 异常。这是典型的用异常来处理正常控制流的方法，在Python中被广泛使用。按照优秀C++代码的标准来看，这是典型的对异常的滥用，既复杂又有额外开销，不推荐使用，但在Python中这是一个广泛遵循的约定。</p><p>相较于Java和Python，Go的错误处理是另一个极端，Go语言则根本没有异常的概念，而是普遍采用返回值的方式来表示错误，同时还提供了panic和recover语法。由于Go有多返回值的特性，避免了错误代码占用返回结果的弊端，所以你可以经常看到函数的最后一个返回值是error类型。由于总是用返回值传递错误，你可以看到Go代码中耦合了大量的错误处理，几乎再每条函数调用语句之后都有一个判断错误是否发生的语句。panic和recover机制十分类似于异常，程序在遇到panic时会一层一层退出调用栈，直到遇到recover。不过recover只在defer中定义，相当于一个函数只有一个recover，而且被recover恢复后会回到错误发生处继续向下执行代码。Go语言倾向于把一般错误都作为返回值传递，除非是非常可怕的、除了重置状态几乎无法恢复错误才会被panic语句抛出。</p><p>Go语言的recover机制和异常比起来，反倒更像Visual Basic语言中的On Error GoTo label及Resume语法。这是一种非结构化的错误处理方式，具体是当声明有On Error GoTo label的函数发生错误以后，会调转到对应的行号，如果再遇到了Resume语句就会返回发生错误的语句后面的一条继续执行，例如下面这段代码：</p><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Sub</span> ErrorDemo</span><br><span class="line">    <span class="keyword">On</span> <span class="keyword">Error</span> <span class="keyword">GoTo</span> ErrorHandler</span><br><span class="line">    <span class="keyword">Dim</span> a <span class="keyword">as</span> <span class="type">Integer</span></span><br><span class="line">    a = <span class="number">1</span>/<span class="number">0</span> <span class="comment">&#x27; An error occurs.</span></span><br><span class="line">    Print a <span class="comment">&#x27; Go back here</span></span><br><span class="line">    <span class="keyword">Exit</span> <span class="keyword">Sub</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">ErrorHandler:</span></span><br><span class="line">    <span class="comment">&#x27; Code that handles errors.</span></span><br><span class="line">    <span class="keyword">Resume</span></span><br><span class="line"><span class="keyword">End</span> <span class="keyword">Sub</span></span><br></pre></td></tr></table></figure><p>Visual Basic中还有On Error Resume Next这样的万能错误处理语句，即遇到错误以后直接忽略并继续执行，这是一种非常危险而且不负责任的做法，但却可以在早期的Visual Basic代码中到处看到。事实上用返回值传递错误代码的时候许多人也并不处理而是直接忽略，这跟On Error Resume Next本质上没有什么区别，却比On Error Resume Next危害更大——因为On Error Resume Next至少还有个标记说明「老子就是这么不负责任」，但忽略错误返回值就难以被一眼发现了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1.前言&quot;&gt;&lt;/a&gt;1.前言&lt;/h2&gt;&lt;p&gt;用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的</summary>
      
    
    
    
    <category term="编程算法" scheme="https://q.billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>最长公共子串问题的后缀数组</title>
    <link href="https://q.billma.top/2021/08/26/lcs-suffix-array/"/>
    <id>https://q.billma.top/2021/08/26/lcs-suffix-array/</id>
    <published>2021-08-26T07:57:30.000Z</published>
    <updated>2021-09-04T13:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长度最大的共有的子串的问题。例如字符串”abcb”,“bca”,“acbc”的LCS就是”bc”。</p><p>求多串的LCS，显然穷举法是极端低效的算法。改进一些的算法是用一个串的每个后缀对其他所有串进行部分匹配，用KMP算法，时间复杂度为O(NL^2)，其中N为字符串个数，L为每个串的长度。更优秀的有广义后缀树的方法，时间可以达到 O(NL)。本文介绍一种基于后缀数组的LCS解法，利用二分查找技术，时间复杂度可以达到O(NLlogL)。</p><h3 id="最长公共子串问题的后缀数组解法"><a href="#最长公共子串问题的后缀数组解法" class="headerlink" title="最长公共子串问题的后缀数组解法"></a>最长公共子串问题的后缀数组解法</h3><p>关于后缀数组的构建方法以及Height数组的性质，本文不再具体介绍，可以参阅IOI国家集训队2004年论文《后缀数组》(许智磊)和IOI国家集训队2009年论文《后缀数组——处理字符串的有力工具》(罗穗骞)。</p><p>回顾一下后缀数组，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]&#x3D;LCP(SA[i],SA[i-1])。连续的一段后缀SA[i..j]的最长公共前缀，就是H[i-1..j]的最小值，即LCP(SA[i..j])&#x3D;Min(H[i-1..j])。</p><p>求N个串的最长公共子串，可以转化为求一些后缀的最长公共前缀的最大值，这些后缀应分属于N个串。具体方法如下：</p><p>设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。S&#x3D;S1[P1]S2[P2]S3…SN-1[PN-1]SN，P1,P2,…PN-1应为不同的N-1个不在字符集中的字符，作为分隔符(后面会解释为什么)。</p><p>接下来，求出字符串S的后缀数组和Height数组，可以用倍增算法，或DC3算法。</p><p>然后二分枚举答案A，假设N个串可以有长度为A的公共字串，并对A的可行性进行验证。如果验证A可行，A’(A’&lt; A)也一定可行，尝试增大A，反之尝试缩小A。最终可以取得A的最大可行值，就是这N个串的最长公共子串的长度。可以证明，尝试次数是O(logL)的。</p><p>于是问题就集中到了，如何验证给定的长度A是否为可行解。方法是，找出在Height数组中找出连续的一段Height[i..j]，使得i&lt;&#x3D;k&lt;&#x3D;j均满足Height[k]&gt;&#x3D;A，并且i-1&lt;&#x3D;k&lt;&#x3D;j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么A就是可行解，否则A不是可行解。</p><p>具体查找i..j时，可以先从前到后枚举i的位置，如果发现Height[i]&gt;&#x3D;A，则开始从i向后枚举j的位置，直到找到了Height[j+1] &lt; A，判断[i..j]这个区间内SA是否分属于S1..SN。如果满足，则A为可行解，然后直接返回，否则令i&#x3D;j+1继续向后枚举。S中每个字符被访问了O(1)次，S的长度为NL+N-1，所以验证的时间复杂度为O(NL)。</p><p>到这里，我们就可以理解为什么分隔符P1..PN-1必须是不同的N-1个不在字符集中的字符了，因为这样才能保证S的后缀的公共前缀不会跨出一个原有串的范围。</p><p>后缀数组是一种处理字符串的强大的数据结构，配合LCP函数与Height数组的性质，后缀数组更是如虎添翼。利用后缀数组，容易地求出了多个串的LCS，而且时空复杂度也相当优秀了。虽然比起后缀树的解法有所不如，但其简明的思路和容易编程的特点却在实际的应用中并不输于后缀树。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长公共子串&quot;&gt;&lt;a href=&quot;#最长公共子串&quot; class=&quot;headerlink&quot; title=&quot;最长公共子串&quot;&gt;&lt;/a&gt;最长公共子串&lt;/h3&gt;&lt;p&gt;最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长</summary>
      
    
    
    
    <category term="编程算法" scheme="https://q.billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>C语言中跨文件的全局变量</title>
    <link href="https://q.billma.top/2021/08/19/c-global-variables-in-multiple-files/"/>
    <id>https://q.billma.top/2021/08/19/c-global-variables-in-multiple-files/</id>
    <published>2021-08-19T08:07:04.000Z</published>
    <updated>2021-09-04T13:03:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先看一段代码</p><p><strong>func.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buf = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">/*Do something else*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.c</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译两个文件，输出的结果是怎样的呢？一眼看上去，可能会输出1，因为两个全局变量buf在不同文件中，又没有extern声明，显然是两个嘛。然而实际上它的运行结果却是2，这说明了这两个文件中引用到的其实是一个变量！</p><p>这是为什么呢？原因是在编译时，C语言编译器将全局符号标记为strong和weak两类：</p><p>函数和初始化的全局符号被标记为strong<br>未初始化的全局符号被标记为weak<br>连接时，连接器对多重定义的全局符号的解析原则如下：</p><p>同一个符号不允许有多个strong定义；<br>假如一个符号有一个strong定义和多个weak定义，那么采用该符号的strong定义；<br>假如一个符号有多个weak定义，那么选取任意一个weak定义<br>由于两个变量一个初始化了，一个没有初始化，所以一个是strong，一个是weak，所以连接器在符号解析时会把他们当成一个。</p><p>如果我们把main.c中的buf也初始化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buf = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  buf = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">func</span>();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次编译就会发现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">duplicate symbol _buf in:</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZ87C6g.o</span><br><span class="line">    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZlES8n.o</span><br><span class="line">ld: 1 duplicate symbol for architecture x86_64</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>这是因为两个全局变量都是strong的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先看一段代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;func.c&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="编程算法" scheme="https://q.billma.top/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="computer,cpp" scheme="https://q.billma.top/tags/computer-cpp/"/>
    
  </entry>
  
  <entry>
    <title>世界最大同性交友网站七夕再搞事————remote  ：Support for password authentication was removed on August 13, 2021.</title>
    <link href="https://q.billma.top/2021/08/15/github-tokenerror/"/>
    <id>https://q.billma.top/2021/08/15/github-tokenerror/</id>
    <published>2021-08-15T07:39:00.000Z</published>
    <updated>2021-09-04T13:42:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原创文章，转载注明出处！</strong></p><h3 id="1-问题背景-background"><a href="#1-问题背景-background" class="headerlink" title="1.问题背景-background"></a>1.问题背景-background</h3><p>如果你在七夕（没错就是2021年8月14日）<strong>的这一天去访问了全球最大的同性交友网站</strong>，<strong>又刚好去更新提交代码</strong>，<strong>或者你创建了一个新的仓库送给自己</strong>，<strong>又刚好想把这个仓库送给github</strong>，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.<br>大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！</p><p><strong>滚！我tm懒得弄！</strong></p><p><img src="https://i.postimg.cc/zG2L02b1/Q-R9-VOLZG-DIN2-V0-HF-S8.png"> </p><p> <strong>Github <a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/">官方解释</a></strong></p><blockquote><p>We described our motivation as we announced similar changes to authenticating with the API as follows:</p></blockquote><blockquote><p>In recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password.</p></blockquote><blockquote><p>Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer.</p></blockquote><blockquote><p>Tokens offer a number of security benefits over password-based authentication:</p></blockquote><blockquote><p>1.Unique – tokens are specific to GitHub and can be generated per use or per device</p></blockquote><blockquote><p>2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials</p></blockquote><blockquote><p>3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case</p></blockquote><blockquote><p>4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be</p></blockquote><p>大概意思就是：<strong>为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。</strong><br>（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。）</p><h3 id="2-什么是token令牌？"><a href="#2-什么是token令牌？" class="headerlink" title="2.什么是token令牌？"></a>2.什么是token令牌？</h3><p>token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。</p><h3 id="3-如何申请token令牌？"><a href="#3-如何申请token令牌？" class="headerlink" title="3.如何申请token令牌？"></a>3.如何申请token令牌？</h3><p>登陆你的GitHub（<strong>注意，在github.com登录你的账户时还是用你的密码，不是令牌</strong>) 点击头像。随后点击settings。</p><p><img src="https://i.postimg.cc/VLBLHGhV/2.png!/scale/50"></p><p>往下拉，你会在左侧看到一个Developer settings。点击它。</p><p><img src="https://i.postimg.cc/1tqy0J6M/31.png"></p><p>左侧有Personal access tokens。点击它。</p><p><img src="https://i.postimg.cc/RZgCv341/4.png"></p><p>点击右侧generate new token。</p><p><img src="https://i.postimg.cc/sD20t1HC/5.png"></p><p>Note是你令牌的名称（不是令牌密码），随便填一个。</p><p>expiration是令牌有效期限。No expiration代表永久令牌。</p><p>下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。</p><p>拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。</p><p><img src="https://i.postimg.cc/NQk5NFqj/6.png"></p><p><strong>警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！</strong>（妥善保管！两情若是久长时，又岂在朝朝暮暮？）</p><p>返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（<strong>但是不会显示该令牌</strong>）。</p><p><img src="https://i.postimg.cc/XvhVyTZp/7.png"></p><p>随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。</p><h3 id="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"><a href="#果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！" class="headerlink" title="果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！"></a>果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原创文章，转载注明出处！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-问题背景-background&quot;&gt;&lt;a href=&quot;#1-问题背景-background&quot; class=&quot;headerlink&quot; title=&quot;1.问题背景-background&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="日常经验" scheme="https://q.billma.top/categories/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/"/>
    
    
  </entry>
  
</feed>
