<!DOCTYPE html><html lang="cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>C++20与C++23关于Module的引入 • Bill Ma's Blog(smarter....)</title><meta name="description" content="C++20与C++23关于Module的引入 - BillMa"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Bill Ma's Blog(smarter....)"><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Bill Ma's Blog(smarter....)" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Bill Ma's Blog(smarter....)"><img class="logo-image" src="/logo.svg" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">C++20与C++23关于Module的引入</h1><div class="post-info"><a></a>2022-02-22</div><div class="post-content"><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>几天前，C++20 草案已经获得了标准委员会的全票通过，C++2a 草案讨论的几个重要内容，比如“概念（concept）”、“范围库（Ranges Library）”、“协程（Coroutines）” 和 “模块（Module）” 都加到 C++20 的标准中了，剩下的就是看编译器厂商的支持速度了。目前看 CLANG 、GCC 和 Microsoft 是比较积极的三家，语言特性和库支持的最快的是 GCC，其次是 CLANG 和 Visual C++，估计最快到年底就能看到支持全部 C++ 20 特性的编译器了。</p>
<p>毫无疑问，在目前主流的编程语言中，C++ 是最难掌握的编程语言，没有之一。C++ 的内容繁杂，知识点多，当然，“坑”也多，非常适合出题考试。正因如此，C++才被认定为了中国计算机协会唯一信息学奥林匹克竞赛的语言（还可以选C，但差不多）除了对初学者门槛太高，传统的 C++ 语言特性上支持的也很弱，与其他编程语言相比，做同样的功能，C++ 往往需要写更多的代码。不过从 C++11 开始，一直到 C++17，这种情况开始有了明显地改善，各种之前被 C++ 社区讽刺为“语法糖”的语言特性逐步被添加到 C++ 语言规范中，比如 lambda 表达式，比如基于范围的 for 循环。应该说，这都是被 Python “逼”的。Python除了运行较C++慢以外，语言简练，格式清爽，扩展性强，早就超越了C++。身为一个竞赛选手，虽然竞赛语言是C++，但是在业余程序设计上，我还是更喜欢使用Python.</p>
<p>所以，C++20便引入了Module（模块）。我第一次看到这玩意的时候，我草，import不是Python的东西吗？怎么被C++用了？后来我仔细阅读了相关文档，才懂得了更多。</p>
<h2 id="老毛病"><a href="#老毛病" class="headerlink" title="老毛病"></a>老毛病</h2><p><strong>此处引用CSDN博主<a target="_blank" rel="noopener" href="https://blog.csdn.net/orbit/article/details/108680567">「吹泡泡的小猫」</a>的文章进行说明，讲得实在是太好了</strong></p>
<h3 id="1-头文件和源文件"><a href="#1-头文件和源文件" class="headerlink" title="1.头文件和源文件"></a>1.头文件和源文件</h3><p>C&#x2F;C++ 语言使用头文件和源文件分离方式迫使程序员养成接口与实现分离的设计习惯的哲学实验事实上是失败了，除了极少的优质项目，大部分的C++项目的源代码组织并没有有效地实施这个原则，反而引入了一大堆头文件难题，extern关键字的“巧用”更是让这个问题雪上加霜。对初学者来说，找不到头文件是最大的“痛”。它就在那儿，为什么编译器就是“视而不见”？那是因为你的包含路径设置不正确，什么绝对路径，什么相对路径，让很多还没入门的初学者过早地体会了“码”生的艰难。学习 C++，从入门到放弃，也许 include 一个“永远”找不到的头文件就够了。</p>
<h3 id="2-剪不断，理还乱"><a href="#2-剪不断，理还乱" class="headerlink" title="2.剪不断，理还乱"></a>2.剪不断，理还乱</h3><p>对于一个大一点的项目来说，头文件之间那种“剪不断、理还乱”的关系最让人头疼不已。头文件之间的循环依赖、互相依赖，你中有我，我中有你。“要用这个接口，只要包含那个叫 A 的头文件就行了，easy！”，你的同事们是否都这样信誓旦旦地跟你说过类似的话？大部分情况下你会发现这个叫 A 的头文件并不单纯，它可能还有“七大姑八大姨”分别位于不同的代码目录中，如果你不设置好头文件的搜索路径，编译器会告诉你人生有多难。当 Java 的程序员在软件架构层面上考虑对象之间的依赖关系时，C++ 的程序员还在为了解决编译问题而试着调整各个头文件的包含顺序，唉，说多了都是泪。</p>
<h3 id="3-编译速度"><a href="#3-编译速度" class="headerlink" title="3.编译速度"></a>3.编译速度</h3><p>C++ 的另一个痛点就是编译速度了。相对于 C++ 的各种“难用”，编译速度太慢才是 C++ 最大的诟病。本人曾在一个大型 C 语言项目中引入了一个 C++ 模块，编译的时候编译器对 C 的源文件和 C++ 的源文件的处理速度明显不在一个数量级上。GCC 在编译 C 语言的源文件的时候，处理速度飞起，输出信息刷屏的速度眼花缭乱。但是在处理 C++ 的源文件的时候，基本上就是以每秒 1 - 2 个这样的目视可见的速度推进。C++ 因为引入了泛型和模板库，支持重载，这使得它的预处理需要做很多事情，慢也是必然的。但是对于一个大型项目来说，这种慢会严重拖累自动化编译、测试和部署的速度，换句话说，就是不“敏捷”。</p>
<p>话不多说，接下来进入正题。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>现在看看 C++20 的 Module 能给我们带来什么。在 Modernes C++ 网站上，可以窥得一些细节，C++20 的 Module 承诺了五个目标：</p>
<h3 id="更快的编译时间（Faster-compile-times）"><a href="#更快的编译时间（Faster-compile-times）" class="headerlink" title="更快的编译时间（Faster compile times）"></a>更快的编译时间（Faster compile times）</h3><p>C++ 的编译器在处理一个源代码文件的时候，首先要做的就是用相应的头文件的内容替换 #include 预编译指令。这就存在一个问题，对每一个源代码文件编译器都要重复一遍内容替换，这会占用大量的处理器时间。替换完的源文件长度也会膨胀数倍，一个源代码文件的处理速度不仅要看这个文件中有多少代码，还要看它包含了多少头文件。使用 Module，只需要 #import 一次（编译器只需要对导入的 Module 做一次解析处理），就可以在所有的源代码文件中使用，没有头文件的替换动作，也不需要重复解析处理 Module，这对编译时间将是一个巨大的优化。</p>
<h3 id="宏的隔离（Isolation-of-macros）"><a href="#宏的隔离（Isolation-of-macros）" class="headerlink" title="宏的隔离（Isolation of macros）"></a>宏的隔离（Isolation of macros）</h3><p>只要你使用 C++ 的时间足够长，你就会碰到这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> XXXX</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">​</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XXXX  ...</span></span><br></pre></td></tr></table></figure>

<p>初次看到这样多此一举的代码，心里肯定会想这是什么鬼？其实见怪不怪，肯定是某个家伙的也定义了一个同样名为 XXXX 的宏，只是值不一样而已。对于同名的宏，如果值也一样，编译器一般“睁一只眼闭一只眼”就放过去了。但是如果值不一样，大多数编译器的默认选项也只是提示一个编译告警，如果你碰巧忽略了这个编译告警，等待你的很可能是痛苦的 Debug 过程。菜鸟们经常抱怨：“我定义的宏的值明明是 5，为什么赋值给变量后变成这个奇怪的值？” 那是因为别人也定义了同名的宏，并且恰巧头文件处理顺序在你的前面。要么调整头文件的包含顺序，要么用上面那段代码，这就是 C++ 程序员的日常工作内容。Module 的使用，可以缓解这种困惑。首先，从语义上讲，可以用 module_name.XXXX 来隔离宏，其次，Module 只需要导入一次，同名宏的先后关系与只与导入顺序一致，不会因为头文件的包含顺序混乱让对某个宏的值你摸不着头脑。</p>
<h3 id="表达代码的逻辑结构（Express-the-logical-structure-of-the-code）"><a href="#表达代码的逻辑结构（Express-the-logical-structure-of-the-code）" class="headerlink" title="表达代码的逻辑结构（Express the logical structure of the code）"></a>表达代码的逻辑结构（Express the logical structure of the code）</h3><p>从设计层面上考虑，头文件其实包含了过多的实现细节，并不适合向外展示，Module 则很好的规避了这一点。首先，作为一个二进制的包，你不想展示给用户的内容，都可以隐藏起来，只将必要的部分标记为 export 即可。其次，你可以按照代码的实现逻辑设计各个 Module，它们可以自由组合形成不同功能的逻辑包提供给客户，这都比给客户一堆平面表达的头文件，然后让客户自己选择组合使用更能满足客户的需求。</p>
<h3 id="让头文件成为“过去式”（Make-header-files-superfluous）"><a href="#让头文件成为“过去式”（Make-header-files-superfluous）" class="headerlink" title="让头文件成为“过去式”（Make header files superfluous）"></a>让头文件成为“过去式”（Make header files superfluous）</h3><p>一个 C++ 项目只要对同一使用的 Module 管理规范，可彻底解决各种包含路径问题。当你想使用某个接口的时候，只要 #import A就行了，再也不用关心该死的头文件搜索路径了，谁说这不“香”呢？毫无疑问，有了 Module，再也不会有人走回头路用头文件了。话又说回来，这也让 C++ 的代码与 Java 代码的相似度又增进了一层，搞不好以后要看源代码文件的扩展名才能区分。</p>
<h3 id="摆脱丑陋的宏环境（Get-rid-of-an-ugly-macro-workarounds）"><a href="#摆脱丑陋的宏环境（Get-rid-of-an-ugly-macro-workarounds）" class="headerlink" title="摆脱丑陋的宏环境（Get rid of an ugly macro workarounds）"></a>摆脱丑陋的宏环境（Get rid of an ugly macro workarounds）</h3><p>前面讲过，C++ 的编译器在对 #include 指令包含的头文件的处理方式是原地展开替换，假如一个源文件包含了头文件 A 和头文件 B，而头文件 B 又不巧间接包含了头文件 A（这种情况在一个大型的 C++ 项目中几乎是常态），那么 A 就会在这个源文件中被展开替换两次。确实是这样的，编译器不仅浪费时间做了展开替换，还会抱怨符号重复定义的错误。所以你会看到每个头文件几乎都是这样用宏环境包裹着自己：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> THIS_HEAD_FILE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THIS_HEAD_FILE_H</span></span><br><span class="line">​</span><br><span class="line">.....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//THIS_HEAD_FILE_H</span></span></span><br></pre></td></tr></table></figure>

<p>也许看的时间长了，觉得这样的代码很规范，其实这是一种多么无奈的选择，还是上面那句话：不用头文件，就不用再浪费时间给每个头文件写这种宏环境了。</p>
<h2 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h2><p>1 实现一个最简单的module<br>module_hello.cppm：定义一个完整的hello模块，并导出一个say_hello_to方法给外部使用。当前各编译器并未规定模块文件的后缀，本文统一使用”.cppm”后缀名。”.cppm”文件有一个专用名称”模块接口文件”，值得注意的是，该文件不光可以声明实体，也可定义实体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> std::string_view&amp; something)</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>&lt;&lt;something&lt;&lt;<span class="string">&quot; !&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main函数中可以直接使用hello模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello_to</span>(std::string_view&#123;<span class="string">&quot;Netease&quot;</span>&#125;);</span><br><span class="line">    <span class="built_in">internal_helper</span>();<span class="comment">//error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译脚本如下，需要先编译module_hello.cppm生成一个pcm文件（module缓存文件），该文件包含了hello模块导出的符号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#buildfile.sh</span></span><br><span class="line">CXX=<span class="string">&quot;clang -fmodules-ts -std=c++2a&quot;</span></span><br><span class="line">$CXX -o module_hello.pcm --precompile -x c++-<span class="keyword">module</span> module_hello.cppm</span><br><span class="line">$CXX -o hello -fprebuilt-<span class="keyword">module</span>-path=. main.cpp hello.cpp</span><br></pre></td></tr></table></figure>

<p>以上代码有以下细节需要注意：</p>
<blockquote>
<p>module hello; 声明了一个模块，前面加一个export，则意味着当前文件是一个模块接口文件（module interface file），只有在模块接口文件中可以导出实体（变量、函数、类、namespace等）。一个模块至少有一个模块接口文件、模块接口文件可以只放实体声明，也可以放实体定义。<br>想要导出一个函数，在函数定义&#x2F;声明前加一个export关键字即可。<br>import hello；不需加尖括号。且不同于include，import 后跟的不是文件名，而是模块名（文件名为module_hello.cpp）。编译器并未强制模块名必须与文件名一致。<br>import的模块不具有传递性。hello模块包含了string_view，但是main函数在使用hello模块前，依然需要再import <string_view>;<br>模块中的import声明需要放在模块声明之后、模块内部其他实体声明之前。即：import ;必须放在export module hello;之后、void internal_helper()之前<br>编译时需要先编译基础的模块，再编译上层模块。buildfile.sh中先将module_hello编译为pcm，再编译main。<br>module_hello.cppm中并未包含say_hello_to函数的声明，而是直接定义实现。编译器会将函数原型等信息放在module_hello.pcm中。</p>
</blockquote>
<h3 id="2-接口与实现分离"><a href="#2-接口与实现分离" class="headerlink" title="2 接口与实现分离"></a>2 接口与实现分离</h3><p>当模块的规模变大、接口变多之后，将所有的实体定义都放在模块接口文件中会非常不利于代码的维护，C++20的模块机制还支持接口与实现分离。<br>module_hello.cppm：我们假设say_hello_to、func_a、func_b等函数十分复杂，.cppm文件中只包含函数的声明（square方法是个例外，它是函数模板，只能定义在.cppm中，不能分离式编译）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> string_view&amp;)</span></span>;</span><br><span class="line"><span class="comment">//缩写的函数模板，C++20新糖果</span></span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="keyword">auto</span> <span class="title">square</span><span class="params">(<span class="type">const</span> <span class="keyword">auto</span>&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>module_hello.cpp：给出hello模块的各个函数声明对应的实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say_hello_to</span><span class="params">(<span class="type">const</span> string_view&amp;)</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello &quot;</span>&lt;&lt;something&lt;&lt;<span class="string">&quot; !&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码有以下细节需要注意：</p>
<blockquote>
<p>整个hello模块分成了 module_hello.cppm和module_hello.cpp两个文件，前者是模块接口文件(module声明前有export关键字)，后者是模块实现文件（module implementation file）。当前各大编译器并未规定模块接口文件的后缀必须是cppm。<br>模块实现文件中不能export任何实体。<br>函数模板，比如代码中的square函数，定义必须放在模块接口文件中，使用auto返回值的函数，定义也必须放在模块接口文件。</p>
</blockquote>
<h3 id="3-可见性控制"><a href="#3-可见性控制" class="headerlink" title="3 可见性控制"></a>3 可见性控制</h3><p>在模块的最开始的例子中，我们就提到了模块的import不具有传递性：<br>main函数使用hello模块的时候必须import <string_view>;。<br>如果想让 hello模块中的string_view模块透给使用者，需使用export import显式声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> &lt;string_view&gt;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>hello模块显示导出string_view后，main文件中便无需再包含string_view了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="comment">//无需再import &lt;string_view&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">say_hello_to</span>(std::string_view&#123;<span class="string">&quot;Netease&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4 子模块（submodule）<br>当模块变得再大一些，仅仅是将模块的接口与实现拆分也有点力不从心：模块实现文件会变得非常大，不便于代码的维护。C++20的模块机制支持子模块。<br>这次module_hello.cppm文件不再定义、声明任何函数，而是仅仅显式导出hello.sub_a、hello.sub_b两个子模块，外部需要的方法都由上述两个子模块定义，module_hello.cppm充当一个“汇总”的角色。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_a;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">import</span> hello.sub_b;</span><br></pre></td></tr></table></figure>

<p>子模块module hello.sub_a采用了接口与实现分离的定义方式：“.cppm”中给出定义，“.cpp”中给出实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_a.cppm（子模块a的接口文件）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_a;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_a.cpp（子模块a的实现文件）</span></span><br><span class="line"><span class="keyword">module</span> hello.sub_a;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>module hello.sub_b同上，不再赘述。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_b.cppm（子模块b的接口文件）</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello.sub_b;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_sub_b.cpp（子模块b的实现文件）</span></span><br><span class="line"><span class="keyword">module</span> hello.sub_b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，hello模块的接口和实现文件各自被拆分到了两个文件中。值得注意的是，C++20的子模块是一种“模拟机制”，模块hello.sub_b是一个完整的模块，中间的点并不代表语法上的从属关系，不同于函数名、变量名等标识符的命名规则，模块的命名规则中允许点存在于模块名字当中。点只是从逻辑语义上帮助程序员理解模块间的逻辑关系。</p>
<h3 id="5-module-partition"><a href="#5-module-partition" class="headerlink" title="5 module partition"></a>5 module partition</h3><p>除了子模块之外，处理复杂模块的机制还有module partition</p>
<p>module partition分为两种：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> implementation partition</span><br><span class="line"><span class="keyword">module</span> interface partition</span><br></pre></td></tr></table></figure>

<p>module implementation partition可以通俗的理解为：将模块的实现文件拆分成多个。<br>module_hello.cppm文件：给出模块的声明、导出函数的声明。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>模块的一部分实现代码拆分到module_hello_partition_internal.cpp文件，该文件实现了一个内部方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_internal.cpp(parititon internal的实现文件，无需给出接口文件)</span></span><br><span class="line"><span class="keyword">module</span> hello:internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模块的另一部分实现拆分到module_hello.cpp文件，该文件实现了func_a、func_b，同时引用了内部方法internal_helper。（func_a、func_b当然也可以拆分到两个cpp文件中）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cpp</span></span><br><span class="line"><span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">import</span> :internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">internal_helper</span>();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是， 模块内部import 一个module partition时，不能import hello:internal;而是直接import :internal; 。</p>
<p>module interface partition可以理解为模块声明拆分到多个文件中。module implementation partition的例子中，函数声明只集中在一个文件中，module interface partition可以将这些声明拆分到多个文件。</p>
<p>首先定义一个内部helper：internal_helper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_internal.cpp(parititon internal的实现文件，无需给出接口文件)</span></span><br><span class="line"><span class="keyword">module</span> hello:internal;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">internal_helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello模块的a部分采用声明+定义合一的方式，定义在module_hello_partition_a.cppm中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_a.cppm（partition a的声明+实现）</span></span><br><span class="line"><span class="keyword">export</span> hello:partition_a;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>hello模块的b部分采用声明+定义分离的方式，module_hello_partition_b.cppm只做声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello_partition_b.cppm（partition b的声明）</span></span><br><span class="line"><span class="keyword">export</span> hello:partition_b;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="title">func_b</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">module_hello_partition_b.cpp给出hello模块的b部分对应的实现：</span><br><span class="line"></span><br><span class="line"><span class="comment">//module_hello_partition_b.cpp（partition b的实现）</span></span><br><span class="line"><span class="keyword">module</span> hello;<span class="comment">//不能使用module hello:partition_b!!!!!!</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>module_hello.cppm再次充当了”汇总“的角色，将模块的a部分+b部分导出给外部使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm //primary module interface file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="keyword">export</span> :partition_a;</span><br><span class="line"><span class="keyword">export</span> :partition_b;</span><br><span class="line"><span class="comment">//export :internal; //编译错误！！！！</span></span><br></pre></td></tr></table></figure>

<p>module implementation partition的使用方式较为直观，相当于我们平时编程中“一个头文件声明多个cpp实现”这种情况。module interface partition有点类似于submodule机制，但语法上有较多差异：</p>
<p>module_hello_partition_b.cpp 第一行不能使用 import hello:partition_b;虽然这样看上去更符合直觉，但是，就是不允许。一个partition name只能创建一个文件<br>每个module partition interface最终必须被primary module interface file导出，不能遗漏。<br>primary module interface file 不能导出module implementation file，只能导出module interface file。故在module_hello.cppm中export :internal;是错误的。<br>同样作为处理大模块的机制，module partition与子模块最本质的区别在于：<br>子模块可以独立的被外部使用者import，而module partition只在模块内部可见，外部无法使用。</p>
<h3 id="6-全局模块片段（Global-module-fragments）"><a href="#6-全局模块片段（Global-module-fragments）" class="headerlink" title="6 全局模块片段（Global module fragments）"></a>6 全局模块片段（Global module fragments）</h3><p>C++20之前有大量的不支持模块的代码、头文件，这些代码实际被隐式的当作全局模块片段处理，模块代码与这些片段交互方式如下：</p>
<p>module; &#x2F;&#x2F;开启了一个全局模块片段，#include必须出现在该行之后、模块声明之前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span><span class="comment">//include一个非模块化的文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"><span class="function"><span class="keyword">export</span> <span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事实上，由于标准库的大多数头文件尚未模块化（VS模块化了部分头文件），2.1～2.5章节的代码在当前编译器环境下(Clang12)是不能直接编译通过的——当前尚不能直接import &lt; iostream &gt; 等模块，通全局模块段则可以进行方便的过渡,另一个过渡方案便是下一节所介绍的module map。</p>
<h3 id="7-module-map"><a href="#7-module-map" class="headerlink" title="7 module map"></a>7 module map</h3><p>module map机制可以将普通的头文件映射成module，进而可以使旧的代码吃到module机制的红利。下面便以clang13中的module map机制为例。<br>假设有一个a.h头文件，该头文件历史较久，不支持module：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.h 该头文件历史较为久远</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func_a</span><span class="params">()</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过给Clang编译器定义一个module.modulemap文件,在该文件中可以将头文件映射成模块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module.modulemap</span></span><br><span class="line"><span class="comment">//改造自定义头文件</span></span><br><span class="line"><span class="keyword">module</span> A &#123;</span><br><span class="line">    header <span class="string">&quot;a.h&quot;</span></span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造C库头文件</span></span><br><span class="line"><span class="keyword">module</span> ctype &#123;</span><br><span class="line">    header <span class="string">&quot;ctype.h&quot;</span></span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//改造C++标准库头文件</span></span><br><span class="line"><span class="keyword">module</span> iostream&#123;</span><br><span class="line">    <span class="keyword">requires</span> cplusplus <span class="comment">//requires cplusplus11 or requires cplusplus17</span></span><br><span class="line">    header <span class="string">&quot;iostream&quot;</span>    </span><br><span class="line">    <span class="keyword">export</span> *</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="keyword">import</span> A;</span><br><span class="line"><span class="keyword">import</span> iostream;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func_a</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;import iostream&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译脚本需要依次编译A、ctype、iostream三个模块，然后再编译main文件：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//buildfile.sh</span></span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o A.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=A</span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o ctype.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=ctype</span><br><span class="line">clang -cc1 -emit-<span class="keyword">module</span> -o iostream.pcm -fmodules <span class="keyword">module</span>.modulemap -fmodule-name=iostream</span><br><span class="line">clang -cc1 -emit-obj main.cpp -fmodules -fmodule-map-file=<span class="keyword">module</span>.modulemap</span><br><span class="line">-fmodule-file=A=A.pcm</span><br><span class="line">-fmodule-file=iostream=iostream.pcm</span><br></pre></td></tr></table></figure>

<p>首先使用-fmodule-map-file参数，指定一个module map file，然后通过-fmodule指定map file中定义的module，就可以将头文件编译成pcm。main文件使用A、iostream等模块时，同样需要使用fmodule-map-file参数指定mdule map文件，同时使用-fmodule指定依赖的模块名称。</p>
<p>注：关于module map机制能够查到的资料较少，有些细节笔者也未能一一查明，例如，通过module map将一个头文件模块化之后，头文件中暴露的宏会如何处理？假如头文件声明的实体的实现分散在多个cpp中，该如何组织modulemap编译？</p>
<h3 id="8-module-与-namespace"><a href="#8-module-与-namespace" class="headerlink" title="8 module 与 namespace"></a>8 module 与 namespace</h3><p>module与namespace是两个维度的概念，在module中同样可以导出namespace：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//module_hello.cppm</span></span><br><span class="line"><span class="keyword">module</span>;</span><br><span class="line">include &lt;iostream&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">namespace</span> hello&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;hello&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.cp</span></span><br><span class="line"><span class="keyword">import</span> hello;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello::<span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>最后，对比最开始提到的头文件的缺点，模块机制有以下几点优势：</p>
<blockquote>
<p>无需重复编译：一个模块的所有接口文件、实现文件，作为一个翻译单元，一次编译后生成pcm，之后遇到import该模块的代码，编译器会从pcm中寻找函数声明等信息。该特性会极大加快C++代码的编译速度。<br>隔离性更好。模块内import的内容，不会泄漏到模块外部，除非显式使用export import声明。<br>顺序无关。import多个模块，无需关心这些模块间的顺序。</p>
</blockquote>
<blockquote>
<p>减少冗余与不一致。小的模块可以直接在单个cppm文件中完成实体的导出、定义。但大的模块依然会把声明、实现拆分到不同文件。</p>
</blockquote>
<blockquote>
<p>子模块、module partition等机制让大模块、超大模块的组织方式更加灵活。</p>
</blockquote>
<blockquote>
<p>全局模块段、module map制使得module与老旧的头文件交互成为可能</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<p>编译器支持不稳定。尚未有编译器完全支持module的所有特性、clang13支持的module map特性不一定保留到主干版本。</p>
</blockquote>
<blockquote>
<p>编译时需要分析依赖关系、先编译最基础的模块。</p>
</blockquote>
<blockquote>
<p>现有的C++工程需要重新组织pipline，且尚未出现自动化的构建系统，需要人工根据依赖关系组构建脚本，实施难度巨大</p>
</blockquote>
<h3 id="module不能做啥？"><a href="#module不能做啥？" class="headerlink" title="module不能做啥？"></a>module不能做啥？</h3><blockquote>
<p>module不能实现代码的二进制分发。依然需要通过源码分发module</p>
</blockquote>
<blockquote>
<p>pcm文件不能通用，不同编译器的pcm文件不能通用、同一编译器不同参数的pcm不能通用</p>
</blockquote>
<blockquote>
<p>无法自动构建，现阶段需要人工组织构建脚本</p>
</blockquote>
<p>编译器如何实现对外隐藏module内部符号的？</p>
<blockquote>
<p>在module机制出现之前，符号的链接性分为外部连接性(external linkage，符号可在文件之间共享)、内部链接性(internal linkage，符号只能在文件内部使用),可以通过extern、static等关键字控制一个符号的链接性。<br>module机制引入了模块链接性(module linkage)，符号可在整个模块内部共享(一个模块可能存在多个partition文件)</p>
</blockquote>
<blockquote>
<p>对于模块export的符号，编译器根据现有规则（外部连接性）对符号进行名称修饰(name mangling)<br>对于module内部的符号，统一在符号名称前面添加“_Zw”名称修饰，这样链接器链接时便不会链接到内部符号。</p>
</blockquote>
<h3 id="失望之处"><a href="#失望之处" class="headerlink" title="失望之处"></a>失望之处</h3><p>最后，说说C++20 Module 特性让我失望的地方，那就是没有统一语言层面上的包管理器。从标准上看，依然是准备留给编译器厂商或第三方机构做这个事情。这不仅让我想起来 C++ 到现在都没有一个语言层面上的 UI 库，虽然第三方的 UI 库倒是不少，但是基本上处于“生殖隔离”的状态，互不通用，编程方法千差万别，也各有优缺点，常常让 C++ 程序员无所适从。对于包管理器，微软推出了 NuGet，但是由于跟自家的 IDE 捆绑太紧密，并没有得到 C++ 社区的广泛支持。Python 之所以好用，是因为 Python 语言的缔造者和整个 Python 社区共同维护一个统一的包管理器，对各种库提供统一的包装接口，使用简单，学习也简单。从现在开始到 C++23 发布还有不到三年时间，希望 C++ 标准委员会能领导整个社区弄一个统一的包管理器，对各种库提供一致的接口封装，避免出现同一个库有多个 Module 封装版本的情况出现，让 C++ 程序员再次无所适从。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/02/24/ru-uk-war/">prev</a><a class="next" href="/2022/02/06/COVID-19-zbzydjq/">next</a></div><div class="copyright"><p>&copy; 2022 <a href="https://q.billma.top">BillMa</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>